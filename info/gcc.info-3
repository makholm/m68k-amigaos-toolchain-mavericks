This is gcc.info, produced by makeinfo version 4.13 from
/Users/lasse/projects/amiga/m68k-amigaos-toolchain/sources/gcc-2.95.3/gcc/gcc.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* gcc: (gcc).                  The GNU Compiler Collection.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU compiler.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Funding
for Free Software" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Funding for Free Software", and this permission notice,
may be included in translations approved by the Free Software Foundation
instead of in the original English.


File: gcc.info,  Node: Disappointments,  Next: C++ Misunderstandings,  Prev: Standard Libraries,  Up: Trouble

7.9 Disappointments and Misunderstandings
=========================================

These problems are perhaps regrettable, but we don't know any practical
way around them.

   * Certain local variables aren't recognized by debuggers when you
     compile with optimization.

     This occurs because sometimes GCC optimizes the variable out of
     existence.  There is no way to tell the debugger how to compute the
     value such a variable "would have had", and it is not clear that
     would be desirable anyway.  So GCC simply does not mention the
     eliminated variable when it writes debugging information.

     You have to expect a certain amount of disagreement between the
     executable and your source code, when you use optimization.

   * Users often think it is a bug when GCC reports an error for code
     like this:

          int foo (struct mumble *);

          struct mumble { ... };

          int foo (struct mumble *x)
          { ... }

     This code really is erroneous, because the scope of `struct
     mumble' in the prototype is limited to the argument list
     containing it.  It does not refer to the `struct mumble' defined
     with file scope immediately below--they are two unrelated types
     with similar names in different scopes.

     But in the definition of `foo', the file-scope type is used
     because that is available to be inherited.  Thus, the definition
     and the prototype do not match, and you get an error.

     This behavior may seem silly, but it's what the ANSI standard
     specifies.  It is easy enough for you to make your code work by
     moving the definition of `struct mumble' above the prototype.
     It's not worth being incompatible with ANSI C just to avoid an
     error for the example shown above.

   * Accesses to bitfields even in volatile objects works by accessing
     larger objects, such as a byte or a word.  You cannot rely on what
     size of object is accessed in order to read or write the bitfield;
     it may even vary for a given bitfield according to the precise
     usage.

     If you care about controlling the amount of memory that is
     accessed, use volatile but do not use bitfields.

   * GCC comes with shell scripts to fix certain known problems in
     system header files.  They install corrected copies of various
     header files in a special directory where only GCC will normally
     look for them.  The scripts adapt to various systems by searching
     all the system header files for the problem cases that we know
     about.

     If new system header files are installed, nothing automatically
     arranges to update the corrected header files.  You will have to
     reinstall GCC to fix the new header files.  More specifically, go
     to the build directory and delete the files `stmp-fixinc' and
     `stmp-headers', and the subdirectory `include'; then do `make
     install' again.

   * On 68000 and x86 systems, for instance, you can get paradoxical
     results if you test the precise values of floating point numbers.
     For example, you can find that a floating point value which is not
     a NaN is not equal to itself.  This results from the fact that the
     floating point registers hold a few more bits of precision than
     fit in a `double' in memory.  Compiled code moves values between
     memory and floating point registers at its convenience, and moving
     them into memory truncates them.

     You can partially avoid this problem by using the `-ffloat-store'
     option (*note Optimize Options::).

   * On the MIPS, variable argument functions using `varargs.h' cannot
     have a floating point value for the first argument.  The reason
     for this is that in the absence of a prototype in scope, if the
     first argument is a floating point, it is passed in a floating
     point register, rather than an integer register.

     If the code is rewritten to use the ANSI standard `stdarg.h'
     method of variable arguments, and the prototype is in scope at the
     time of the call, everything will work fine.

   * On the H8/300 and H8/300H, variable argument functions must be
     implemented using the ANSI standard `stdarg.h' method of variable
     arguments.  Furthermore, calls to functions using `stdarg.h'
     variable arguments must have a prototype for the called function
     in scope at the time of the call.


File: gcc.info,  Node: C++ Misunderstandings,  Next: Protoize Caveats,  Prev: Disappointments,  Up: Trouble

7.10 Common Misunderstandings with GNU C++
==========================================

C++ is a complex language and an evolving one, and its standard
definition (the ISO C++ standard) was only recently completed.  As a
result, your C++ compiler may occasionally surprise you, even when its
behavior is correct.  This section discusses some areas that frequently
give rise to questions of this sort.

* Menu:

* Static Definitions::  Static member declarations are not definitions
* Temporaries::         Temporaries may vanish before you expect
* Copy Assignment::     Copy Assignment operators copy virtual bases twice


File: gcc.info,  Node: Static Definitions,  Next: Temporaries,  Up: C++ Misunderstandings

7.10.1 Declare _and_ Define Static Members
------------------------------------------

When a class has static data members, it is not enough to _declare_ the
static member; you must also _define_ it.  For example:

     class Foo
     {
       ...
       void method();
       static int bar;
     };

   This declaration only establishes that the class `Foo' has an `int'
named `Foo::bar', and a member function named `Foo::method'.  But you
still need to define _both_ `method' and `bar' elsewhere.  According to
the draft ANSI standard, you must supply an initializer in one (and
only one) source file, such as:

     int Foo::bar = 0;

   Other C++ compilers may not correctly implement the standard
behavior.  As a result, when you switch to `g++' from one of these
compilers, you may discover that a program that appeared to work
correctly in fact does not conform to the standard: `g++' reports as
undefined symbols any static data members that lack definitions.


File: gcc.info,  Node: Temporaries,  Next: Copy Assignment,  Prev: Static Definitions,  Up: C++ Misunderstandings

7.10.2 Temporaries May Vanish Before You Expect
-----------------------------------------------

It is dangerous to use pointers or references to _portions_ of a
temporary object.  The compiler may very well delete the object before
you expect it to, leaving a pointer to garbage.  The most common place
where this problem crops up is in classes like string classes,
especially ones that define a conversion function to type `char *' or
`const char *' - which is one reason why the standard `string' class
requires you to call the `c_str' member function.  However, any class
that returns a pointer to some internal structure is potentially
subject to this problem.

   For example, a program may use a function `strfunc' that returns
`string' objects, and another function `charfunc' that operates on
pointers to `char':

     string strfunc ();
     void charfunc (const char *);

     void
     f ()
     {
       const char *p = strfunc().c_str();
       ...
       charfunc (p);
       ...
       charfunc (p);
     }

In this situation, it may seem reasonable to save a pointer to the C
string returned by the `c_str' member function and use that rather than
call `c_str' repeatedly.  However, the temporary string created by the
call to `strfunc' is destroyed after `p' is initialized, at which point
`p' is left pointing to freed memory.

   Code like this may run successfully under some other compilers,
particularly obsolete cfront-based compilers that delete temporaries
along with normal local variables.  However, the GNU C++ behavior is
standard-conforming, so if your program depends on late destruction of
temporaries it is not portable.

   The safe way to write such code is to give the temporary a name,
which forces it to remain until the end of the scope of the name.  For
example:

     string& tmp = strfunc ();
     charfunc (tmp.c_str ());


File: gcc.info,  Node: Copy Assignment,  Prev: Temporaries,  Up: C++ Misunderstandings

7.10.3 Implicit Copy-Assignment for Virtual Bases
-------------------------------------------------

When a base class is virtual, only one subobject of the base class
belongs to each full object. Also, the constructors and destructors are
invoked only once, and called from the most-derived class. However, such
objects behave unspecified when being assigned. For example:

     struct Base{
       char *name;
       Base(char *n) : name(strdup(n)){}
       Base& operator= (const Base& other){
        free (name);
        name = strdup (other.name);
       }
     };

     struct A:virtual Base{
       int val;
       A():Base("A"){}
     };

     struct B:virtual Base{
       int bval;
       B():Base("B"){}
     };

     struct Derived:public A, public B{
       Derived():Base("Derived"){}
     };

     void func(Derived &d1, Derived &d2)
     {
       d1 = d2;
     }

   The C++ standard specifies that `Base::Base' is only called once
when constructing or copy-constructing a Derived object. It is
unspecified whether `Base::operator=' is called more than once when the
implicit copy-assignment for Derived objects is invoked (as it is
inside `func' in the example).

   g++ implements the "intuitive" algorithm for copy-assignment: assign
all direct bases, then assign all members. In that algorithm, the
virtual base subobject can be encountered many times. In the example,
copying proceeds in the following order: `val', `name' (via `strdup'),
`bval', and `name' again.

   If application code relies on copy-assignment, a user-defined
copy-assignment operator removes any uncertainties. With such an
operator, the application can define whether and how the virtual base
subobject is assigned.


File: gcc.info,  Node: Protoize Caveats,  Next: Non-bugs,  Prev: C++ Misunderstandings,  Up: Trouble

7.11 Caveats of using `protoize'
================================

The conversion programs `protoize' and `unprotoize' can sometimes
change a source file in a way that won't work unless you rearrange it.

   * `protoize' can insert references to a type name or type tag before
     the definition, or in a file where they are not defined.

     If this happens, compiler error messages should show you where the
     new references are, so fixing the file by hand is straightforward.

   * There are some C constructs which `protoize' cannot figure out.
     For example, it can't determine argument types for declaring a
     pointer-to-function variable; this you must do by hand.  `protoize'
     inserts a comment containing `???' each time it finds such a
     variable; so you can find all such variables by searching for this
     string.  ANSI C does not require declaring the argument types of
     pointer-to-function types.

   * Using `unprotoize' can easily introduce bugs.  If the program
     relied on prototypes to bring about conversion of arguments, these
     conversions will not take place in the program without prototypes.
     One case in which you can be sure `unprotoize' is safe is when you
     are removing prototypes that were made with `protoize'; if the
     program worked before without any prototypes, it will work again
     without them.

     You can find all the places where this problem might occur by
     compiling the program with the `-Wconversion' option.  It prints a
     warning whenever an argument is converted.

   * Both conversion programs can be confused if there are macro calls
     in and around the text to be converted.  In other words, the
     standard syntax for a declaration or definition must not result
     from expanding a macro.  This problem is inherent in the design of
     C and cannot be fixed.  If only a few functions have confusing
     macro calls, you can easily convert them manually.

   * `protoize' cannot get the argument types for a function whose
     definition was not actually compiled due to preprocessing
     conditionals.  When this happens, `protoize' changes nothing in
     regard to such a function.  `protoize' tries to detect such
     instances and warn about them.

     You can generally work around this problem by using `protoize' step
     by step, each time specifying a different set of `-D' options for
     compilation, until all of the functions have been converted.
     There is no automatic way to verify that you have got them all,
     however.

   * Confusion may result if there is an occasion to convert a function
     declaration or definition in a region of source code where there
     is more than one formal parameter list present.  Thus, attempts to
     convert code containing multiple (conditionally compiled) versions
     of a single function header (in the same vicinity) may not produce
     the desired (or expected) results.

     If you plan on converting source files which contain such code, it
     is recommended that you first make sure that each conditionally
     compiled region of source code which contains an alternative
     function header also contains at least one additional follower
     token (past the final right parenthesis of the function header).
     This should circumvent the problem.

   * `unprotoize' can become confused when trying to convert a function
     definition or declaration which contains a declaration for a
     pointer-to-function formal argument which has the same name as the
     function being defined or declared.  We recommand you avoid such
     choices of formal parameter names.

   * You might also want to correct some of the indentation by hand and
     break long lines.  (The conversion programs don't write lines
     longer than eighty characters in any case.)


File: gcc.info,  Node: Non-bugs,  Next: Warnings and Errors,  Prev: Protoize Caveats,  Up: Trouble

7.12 Certain Changes We Don't Want to Make
==========================================

This section lists changes that people frequently request, but which we
do not make because we think GCC is better without them.

   * Checking the number and type of arguments to a function which has
     an old-fashioned definition and no prototype.

     Such a feature would work only occasionally--only for calls that
     appear in the same file as the called function, following the
     definition.  The only way to check all calls reliably is to add a
     prototype for the function.  But adding a prototype eliminates the
     motivation for this feature.  So the feature is not worthwhile.

   * Warning about using an expression whose type is signed as a shift
     count.

     Shift count operands are probably signed more often than unsigned.
     Warning about this would cause far more annoyance than good.

   * Warning about assigning a signed value to an unsigned variable.

     Such assignments must be very common; warning about them would
     cause more annoyance than good.

   * Warning about unreachable code.

     It's very common to have unreachable code in machine-generated
     programs.  For example, this happens normally in some files of GNU
     C itself.

   * Warning when a non-void function value is ignored.

     Coming as I do from a Lisp background, I balk at the idea that
     there is something dangerous about discarding a value.  There are
     functions that return values which some callers may find useful;
     it makes no sense to clutter the program with a cast to `void'
     whenever the value isn't useful.

   * Assuming (for optimization) that the address of an external symbol
     is never zero.

     This assumption is false on certain systems when `#pragma weak' is
     used.

   * Making `-fshort-enums' the default.

     This would cause storage layout to be incompatible with most other
     C compilers.  And it doesn't seem very important, given that you
     can get the same result in other ways.  The case where it matters
     most is when the enumeration-valued object is inside a structure,
     and in that case you can specify a field width explicitly.

   * Making bitfields unsigned by default on particular machines where
     "the ABI standard" says to do so.

     The ANSI C standard leaves it up to the implementation whether a
     bitfield declared plain `int' is signed or not.  This in effect
     creates two alternative dialects of C.

     The GNU C compiler supports both dialects; you can specify the
     signed dialect with `-fsigned-bitfields' and the unsigned dialect
     with `-funsigned-bitfields'.  However, this leaves open the
     question of which dialect to use by default.

     Currently, the preferred dialect makes plain bitfields signed,
     because this is simplest.  Since `int' is the same as `signed int'
     in every other context, it is cleanest for them to be the same in
     bitfields as well.

     Some computer manufacturers have published Application Binary
     Interface standards which specify that plain bitfields should be
     unsigned.  It is a mistake, however, to say anything about this
     issue in an ABI.  This is because the handling of plain bitfields
     distinguishes two dialects of C.  Both dialects are meaningful on
     every type of machine.  Whether a particular object file was
     compiled using signed bitfields or unsigned is of no concern to
     other object files, even if they access the same bitfields in the
     same data structures.

     A given program is written in one or the other of these two
     dialects.  The program stands a chance to work on most any machine
     if it is compiled with the proper dialect.  It is unlikely to work
     at all if compiled with the wrong dialect.

     Many users appreciate the GNU C compiler because it provides an
     environment that is uniform across machines.  These users would be
     inconvenienced if the compiler treated plain bitfields differently
     on certain machines.

     Occasionally users write programs intended only for a particular
     machine type.  On these occasions, the users would benefit if the
     GNU C compiler were to support by default the same dialect as the
     other compilers on that machine.  But such applications are rare.
     And users writing a program to run on more than one type of
     machine cannot possibly benefit from this kind of compatibility.

     This is why GCC does and will treat plain bitfields in the same
     fashion on all types of machines (by default).

     There are some arguments for making bitfields unsigned by default
     on all machines.  If, for example, this becomes a universal de
     facto standard, it would make sense for GCC to go along with it.
     This is something to be considered in the future.

     (Of course, users strongly concerned about portability should
     indicate explicitly in each bitfield whether it is signed or not.
     In this way, they write programs which have the same meaning in
     both C dialects.)

   * Undefining `__STDC__' when `-ansi' is not used.

     Currently, GCC defines `__STDC__' as long as you don't use
     `-traditional'.  This provides good results in practice.

     Programmers normally use conditionals on `__STDC__' to ask whether
     it is safe to use certain features of ANSI C, such as function
     prototypes or ANSI token concatenation.  Since plain `gcc' supports
     all the features of ANSI C, the correct answer to these questions
     is "yes".

     Some users try to use `__STDC__' to check for the availability of
     certain library facilities.  This is actually incorrect usage in
     an ANSI C program, because the ANSI C standard says that a
     conforming freestanding implementation should define `__STDC__'
     even though it does not have the library facilities.  `gcc -ansi
     -pedantic' is a conforming freestanding implementation, and it is
     therefore required to define `__STDC__', even though it does not
     come with an ANSI C library.

     Sometimes people say that defining `__STDC__' in a compiler that
     does not completely conform to the ANSI C standard somehow
     violates the standard.  This is illogical.  The standard is a
     standard for compilers that claim to support ANSI C, such as `gcc
     -ansi'--not for other compilers such as plain `gcc'.  Whatever the
     ANSI C standard says is relevant to the design of plain `gcc'
     without `-ansi' only for pragmatic reasons, not as a requirement.

     GCC normally defines `__STDC__' to be 1, and in addition defines
     `__STRICT_ANSI__' if you specify the `-ansi' option.  On some
     hosts, system include files use a different convention, where
     `__STDC__' is normally 0, but is 1 if the user specifies strict
     conformance to the C Standard.  GCC follows the host convention
     when processing system include files, but when processing user
     files it follows the usual GNU C convention.

   * Undefining `__STDC__' in C++.

     Programs written to compile with C++-to-C translators get the
     value of `__STDC__' that goes with the C compiler that is
     subsequently used.  These programs must test `__STDC__' to
     determine what kind of C preprocessor that compiler uses: whether
     they should concatenate tokens in the ANSI C fashion or in the
     traditional fashion.

     These programs work properly with GNU C++ if `__STDC__' is defined.
     They would not work otherwise.

     In addition, many header files are written to provide prototypes
     in ANSI C but not in traditional C.  Many of these header files
     can work without change in C++ provided `__STDC__' is defined.  If
     `__STDC__' is not defined, they will all fail, and will all need
     to be changed to test explicitly for C++ as well.

   * Deleting "empty" loops.

     Historically, GCC has not deleted "empty" loops under the
     assumption that the most likely reason you would put one in a
     program is to have a delay, so deleting them will not make real
     programs run any faster.

     However, the rationale here is that optimization of a nonempty loop
     cannot produce an empty one, which holds for C but is not always
     the case for C++.

     Moreover, with `-funroll-loops' small "empty" loops are already
     removed, so the current behavior is both sub-optimal and
     inconsistent and will change in the future.

   * Making side effects happen in the same order as in some other
     compiler.

     It is never safe to depend on the order of evaluation of side
     effects.  For example, a function call like this may very well
     behave differently from one compiler to another:

          void func (int, int);

          int i = 2;
          func (i++, i++);

     There is no guarantee (in either the C or the C++ standard language
     definitions) that the increments will be evaluated in any
     particular order.  Either increment might happen first.  `func'
     might get the arguments `2, 3', or it might get `3, 2', or even
     `2, 2'.

   * Not allowing structures with volatile fields in registers.

     Strictly speaking, there is no prohibition in the ANSI C standard
     against allowing structures with volatile fields in registers, but
     it does not seem to make any sense and is probably not what you
     wanted to do.  So the compiler will give an error message in this
     case.


File: gcc.info,  Node: Warnings and Errors,  Prev: Non-bugs,  Up: Trouble

7.13 Warning Messages and Error Messages
========================================

The GNU compiler can produce two kinds of diagnostics: errors and
warnings.  Each kind has a different purpose:

     _Errors_ report problems that make it impossible to compile your
     program.  GCC reports errors with the source file name and line
     number where the problem is apparent.

     _Warnings_ report other unusual conditions in your code that _may_
     indicate a problem, although compilation can (and does) proceed.
     Warning messages also report the source file name and line number,
     but include the text `warning:' to distinguish them from error
     messages.

   Warnings may indicate danger points where you should check to make
sure that your program really does what you intend; or the use of
obsolete features; or the use of nonstandard features of GNU C or C++.
Many warnings are issued only if you ask for them, with one of the `-W'
options (for instance, `-Wall' requests a variety of useful warnings).

   GCC always tries to compile your program if possible; it never
gratuitously rejects a program whose meaning is clear merely because
(for instance) it fails to conform to a standard.  In some cases,
however, the C and C++ standards specify that certain extensions are
forbidden, and a diagnostic _must_ be issued by a conforming compiler.
The `-pedantic' option tells GCC to issue warnings in such cases;
`-pedantic-errors' says to make them errors instead.  This does not
mean that _all_ non-ANSI constructs get warnings or errors.

   *Note Options to Request or Suppress Warnings: Warning Options, for
more detail on these and related command-line options.


File: gcc.info,  Node: Bugs,  Next: Service,  Prev: Trouble,  Up: Top

8 Reporting Bugs
****************

Your bug reports play an essential role in making GCC reliable.

   When you encounter a problem, the first thing to do is to see if it
is already known.  *Note Trouble::.  If it isn't known, then you should
report the problem.

   Reporting a bug may help you by bringing a solution to your problem,
or it may not.  (If it does not, look in the service directory; see
*note Service::.)  In any case, the principal function of a bug report
is to help the entire community by making the next version of GCC work
better.  Bug reports are your contribution to the maintenance of GCC.

   Since the maintainers are very overloaded, we cannot respond to every
bug report.  However, if the bug has not been fixed, we are likely to
send you a patch and ask you to tell us whether it works.

   In order for a bug report to serve its purpose, you must include the
information that makes for fixing the bug.

* Menu:

* Criteria:  Bug Criteria.   Have you really found a bug?
* Where: Bug Lists.	     Where to send your bug report.
* Reporting: Bug Reporting.  How to report a bug effectively.
* Patches: Sending Patches.  How to send a patch for GCC.
* Known: Trouble.            Known problems.
* Help: Service.             Where to ask for help.


File: gcc.info,  Node: Bug Criteria,  Next: Bug Lists,  Up: Bugs

8.1 Have You Found a Bug?
=========================

If you are not sure whether you have found a bug, here are some
guidelines:

   * If the compiler gets a fatal signal, for any input whatever, that
     is a compiler bug.  Reliable compilers never crash.

   * If the compiler produces invalid assembly code, for any input
     whatever (except an `asm' statement), that is a compiler bug,
     unless the compiler reports errors (not just warnings) which would
     ordinarily prevent the assembler from being run.

   * If the compiler produces valid assembly code that does not
     correctly execute the input source code, that is a compiler bug.

     However, you must double-check to make sure, because you may have
     run into an incompatibility between GNU C and traditional C (*note
     Incompatibilities::).  These incompatibilities might be considered
     bugs, but they are inescapable consequences of valuable features.

     Or you may have a program whose behavior is undefined, which
     happened by chance to give the desired results with another C or
     C++ compiler.

     For example, in many nonoptimizing compilers, you can write `x;'
     at the end of a function instead of `return x;', with the same
     results.  But the value of the function is undefined if `return'
     is omitted; it is not a bug when GCC produces different results.

     Problems often result from expressions with two increment
     operators, as in `f (*p++, *p++)'.  Your previous compiler might
     have interpreted that expression the way you intended; GCC might
     interpret it another way.  Neither compiler is wrong.  The bug is
     in your code.

     After you have localized the error to a single source line, it
     should be easy to check for these things.  If your program is
     correct and well defined, you have found a compiler bug.

   * If the compiler produces an error message for valid input, that is
     a compiler bug.

   * If the compiler does not produce an error message for invalid
     input, that is a compiler bug.  However, you should note that your
     idea of "invalid input" might be my idea of "an extension" or
     "support for traditional practice".

   * If you are an experienced user of C or C++ (or Fortran or
     Objective-C) compilers, your suggestions for improvement of GCC
     are welcome in any case.


File: gcc.info,  Node: Bug Lists,  Next: Bug Reporting,  Prev: Bug Criteria,  Up: Bugs

8.2 Where to Report Bugs
========================

Send bug reports for the GNU Compiler Collection to
`gcc-bugs@gcc.gnu.org'.  In accordance with the GNU-wide convention, in
which bug reports for tool "foo" are sent to `bug-foo@gnu.org', the
address `bug-gcc@gnu.org' may also be used; it will forward to the
address given above.

   Please read `<URL:http://www.gnu.org/software/gcc/bugs.html>' for
bug reporting instructions before you post a bug report.

   Often people think of posting bug reports to the newsgroup instead of
mailing them.  This appears to work, but it has one problem which can be
crucial: a newsgroup posting does not contain a mail path back to the
sender.  Thus, if maintainers need more information, they may be unable
to reach you.  For this reason, you should always send bug reports by
mail to the proper mailing list.

   As a last resort, send bug reports on paper to:

     GNU Compiler Bugs
     Free Software Foundation
     59 Temple Place - Suite 330
     Boston, MA 02111-1307, USA


File: gcc.info,  Node: Bug Reporting,  Next: Sending Patches,  Prev: Bug Lists,  Up: Bugs

8.3 How to Report Bugs
======================

You may find additional and/or more up-to-date instructions at
`<URL:http://www.gnu.org/software/gcc/bugs.html>'.

   The fundamental principle of reporting bugs usefully is this:
*report all the facts*.  If you are not sure whether to state a fact or
leave it out, state it!

   Often people omit facts because they think they know what causes the
problem and they conclude that some details don't matter.  Thus, you
might assume that the name of the variable you use in an example does
not matter.  Well, probably it doesn't, but one cannot be sure.
Perhaps the bug is a stray memory reference which happens to fetch from
the location where that name is stored in memory; perhaps, if the name
were different, the contents of that location would fool the compiler
into doing the right thing despite the bug.  Play it safe and give a
specific, complete example.  That is the easiest thing for you to do,
and the most helpful.

   Keep in mind that the purpose of a bug report is to enable someone to
fix the bug if it is not known.  It isn't very important what happens if
the bug is already known.  Therefore, always write your bug reports on
the assumption that the bug is not known.

   Sometimes people give a few sketchy facts and ask, "Does this ring a
bell?"  This cannot help us fix a bug, so it is basically useless.  We
respond by asking for enough details to enable us to investigate.  You
might as well expedite matters by sending them to begin with.

   Try to make your bug report self-contained.  If we have to ask you
for more information, it is best if you include all the previous
information in your response, as well as the information that was
missing.

   Please report each bug in a separate message.  This makes it easier
for us to track which bugs have been fixed and to forward your bugs
reports to the appropriate maintainer.

   To enable someone to investigate the bug, you should include all
these things:

   * The version of GCC.  You can get this by running it with the `-v'
     option.

     Without this, we won't know whether there is any point in looking
     for the bug in the current version of GCC.

   * A complete input file that will reproduce the bug.  If the bug is
     in the C preprocessor, send a source file and any header files
     that it requires.  If the bug is in the compiler proper (`cc1'),
     send the preprocessor output generated by adding `-save-temps' to
     the compilation command (*note Debugging Options::).  When you do
     this, use the same `-I', `-D' or `-U' options that you used in
     actual compilation. Then send the INPUT.i or INPUT.ii files
     generated.

     A single statement is not enough of an example.  In order to
     compile it, it must be embedded in a complete file of compiler
     input; and the bug might depend on the details of how this is done.

     Without a real example one can compile, all anyone can do about
     your bug report is wish you luck.  It would be futile to try to
     guess how to provoke the bug.  For example, bugs in register
     allocation and reloading frequently depend on every little detail
     of the function they happen in.

     Even if the input file that fails comes from a GNU program, you
     should still send the complete test case.  Don't ask the GCC
     maintainers to do the extra work of obtaining the program in
     question--they are all overworked as it is.  Also, the problem may
     depend on what is in the header files on your system; it is
     unreliable for the GCC maintainers to try the problem with the
     header files available to them.  By sending CPP output, you can
     eliminate this source of uncertainty and save us a certain
     percentage of wild goose chases.

   * The command arguments you gave GCC to compile that example and
     observe the bug.  For example, did you use `-O'?  To guarantee you
     won't omit something important, list all the options.

     If we were to try to guess the arguments, we would probably guess
     wrong and then we would not encounter the bug.

   * The type of machine you are using, and the operating system name
     and version number.

   * The operands you gave to the `configure' command when you installed
     the compiler.

   * A complete list of any modifications you have made to the compiler
     source.  (We don't promise to investigate the bug unless it
     happens in an unmodified compiler.  But if you've made
     modifications and don't tell us, then you are sending us on a wild
     goose chase.)

     Be precise about these changes.  A description in English is not
     enough--send a context diff for them.

     Adding files of your own (such as a machine description for a
     machine we don't support) is a modification of the compiler source.

   * Details of any other deviations from the standard procedure for
     installing GCC.

   * A description of what behavior you observe that you believe is
     incorrect.  For example, "The compiler gets a fatal signal," or,
     "The assembler instruction at line 208 in the output is incorrect."

     Of course, if the bug is that the compiler gets a fatal signal,
     then one can't miss it.  But if the bug is incorrect output, the
     maintainer might not notice unless it is glaringly wrong.  None of
     us has time to study all the assembler code from a 50-line C
     program just on the chance that one instruction might be wrong.
     We need _you_ to do this part!

     Even if the problem you experience is a fatal signal, you should
     still say so explicitly.  Suppose something strange is going on,
     such as, your copy of the compiler is out of synch, or you have
     encountered a bug in the C library on your system.  (This has
     happened!)  Your copy might crash and the copy here would not.  If
     you said to expect a crash, then when the compiler here fails to
     crash, we would know that the bug was not happening.  If you don't
     say to expect a crash, then we would not know whether the bug was
     happening.  We would not be able to draw any conclusion from our
     observations.

     If the problem is a diagnostic when compiling GCC with some other
     compiler, say whether it is a warning or an error.

     Often the observed symptom is incorrect output when your program
     is run.  Sad to say, this is not enough information unless the
     program is short and simple.  None of us has time to study a large
     program to figure out how it would work if compiled correctly,
     much less which line of it was compiled wrong.  So you will have
     to do that.  Tell us which source line it is, and what incorrect
     result happens when that line is executed.  A person who
     understands the program can find this as easily as finding a bug
     in the program itself.

   * If you send examples of assembler code output from GCC, please use
     `-g' when you make them.  The debugging information includes
     source line numbers which are essential for correlating the output
     with the input.

   * If you wish to mention something in the GCC source, refer to it by
     context, not by line number.

     The line numbers in the development sources don't match those in
     your sources.  Your line numbers would convey no useful
     information to the maintainers.

   * Additional information from a debugger might enable someone to
     find a problem on a machine which he does not have available.
     However, you need to think when you collect this information if
     you want it to have any chance of being useful.

     For example, many people send just a backtrace, but that is never
     useful by itself.  A simple backtrace with arguments conveys little
     about GCC because the compiler is largely data-driven; the same
     functions are called over and over for different RTL insns, doing
     different things depending on the details of the insn.

     Most of the arguments listed in the backtrace are useless because
     they are pointers to RTL list structure.  The numeric values of the
     pointers, which the debugger prints in the backtrace, have no
     significance whatever; all that matters is the contents of the
     objects they point to (and most of the contents are other such
     pointers).

     In addition, most compiler passes consist of one or more loops that
     scan the RTL insn sequence.  The most vital piece of information
     about such a loop--which insn it has reached--is usually in a
     local variable, not in an argument.

     What you need to provide in addition to a backtrace are the values
     of the local variables for several stack frames up.  When a local
     variable or an argument is an RTX, first print its value and then
     use the GDB command `pr' to print the RTL expression that it points
     to.  (If GDB doesn't run on your machine, use your debugger to call
     the function `debug_rtx' with the RTX as an argument.)  In
     general, whenever a variable is a pointer, its value is no use
     without the data it points to.

   Here are some things that are not necessary:

   * A description of the envelope of the bug.

     Often people who encounter a bug spend a lot of time investigating
     which changes to the input file will make the bug go away and which
     changes will not affect it.

     This is often time consuming and not very useful, because the way
     we will find the bug is by running a single example under the
     debugger with breakpoints, not by pure deduction from a series of
     examples.  You might as well save your time for something else.

     Of course, if you can find a simpler example to report _instead_ of
     the original one, that is a convenience.  Errors in the output
     will be easier to spot, running under the debugger will take less
     time, etc.  Most GCC bugs involve just one function, so the most
     straightforward way to simplify an example is to delete all the
     function definitions except the one where the bug occurs.  Those
     earlier in the file may be replaced by external declarations if
     the crucial function depends on them.  (Exception: inline
     functions may affect compilation of functions defined later in the
     file.)

     However, simplification is not vital; if you don't want to do this,
     report the bug anyway and send the entire test case you used.

   * In particular, some people insert conditionals `#ifdef BUG' around
     a statement which, if removed, makes the bug not happen.  These
     are just clutter; we won't pay any attention to them anyway.
     Besides, you should send us cpp output, and that can't have
     conditionals.

   * A patch for the bug.

     A patch for the bug is useful if it is a good one.  But don't omit
     the necessary information, such as the test case, on the
     assumption that a patch is all we need.  We might see problems
     with your patch and decide to fix the problem another way, or we
     might not understand it at all.

     Sometimes with a program as complicated as GCC it is very hard to
     construct an example that will make the program follow a certain
     path through the code.  If you don't send the example, we won't be
     able to construct one, so we won't be able to verify that the bug
     is fixed.

     And if we can't understand what bug you are trying to fix, or why
     your patch should be an improvement, we won't install it.  A test
     case will help us to understand.

     *Note Sending Patches::, for guidelines on how to make it easy for
     us to understand and install your patches.

   * A guess about what the bug is or what it depends on.

     Such guesses are usually wrong.  Even I can't guess right about
     such things without first using the debugger to find the facts.

   * A core dump file.

     We have no way of examining a core dump for your type of machine
     unless we have an identical system--and if we do have one, we
     should be able to reproduce the crash ourselves.


File: gcc.info,  Node: Sending Patches,  Prev: Bug Reporting,  Up: Bugs

8.4 Sending Patches for GCC
===========================

If you would like to write bug fixes or improvements for the GNU C
compiler, that is very helpful.  Send suggested fixes to the patches
mailing list, `gcc-patches@gcc.gnu.org'.

   Please follow these guidelines so we can study your patches
efficiently.  If you don't follow these guidelines, your information
might still be useful, but using it will take extra work.  Maintaining
GNU C is a lot of work in the best of circumstances, and we can't keep
up unless you do your best to help.

   * Send an explanation with your changes of what problem they fix or
     what improvement they bring about.  For a bug fix, just include a
     copy of the bug report, and explain why the change fixes the bug.

     (Referring to a bug report is not as good as including it, because
     then we will have to look it up, and we have probably already
     deleted it if we've already fixed the bug.)

   * Always include a proper bug report for the problem you think you
     have fixed.  We need to convince ourselves that the change is
     right before installing it.  Even if it is right, we might have
     trouble judging it if we don't have a way to reproduce the problem.

   * Include all the comments that are appropriate to help people
     reading the source in the future understand why this change was
     needed.

   * Don't mix together changes made for different reasons.  Send them
     _individually_.

     If you make two changes for separate reasons, then we might not
     want to install them both.  We might want to install just one.  If
     you send them all jumbled together in a single set of diffs, we
     have to do extra work to disentangle them--to figure out which
     parts of the change serve which purpose.  If we don't have time
     for this, we might have to ignore your changes entirely.

     If you send each change as soon as you have written it, with its
     own explanation, then the two changes never get tangled up, and we
     can consider each one properly without any extra work to
     disentangle them.

     Ideally, each change you send should be impossible to subdivide
     into parts that we might want to consider separately, because each
     of its parts gets its motivation from the other parts.

   * Send each change as soon as that change is finished.  Sometimes
     people think they are helping us by accumulating many changes to
     send them all together.  As explained above, this is absolutely
     the worst thing you could do.

     Since you should send each change separately, you might as well
     send it right away.  That gives us the option of installing it
     immediately if it is important.

   * Use `diff -c' to make your diffs.  Diffs without context are hard
     for us to install reliably.  More than that, they make it hard for
     us to study the diffs to decide whether we want to install them.
     Unidiff format is better than contextless diffs, but not as easy
     to read as `-c' format.

     If you have GNU diff, use `diff -cp', which shows the name of the
     function that each change occurs in.

   * Write the change log entries for your changes.  We get lots of
     changes, and we don't have time to do all the change log writing
     ourselves.

     Read the `ChangeLog' file to see what sorts of information to put
     in, and to learn the style that we use.  The purpose of the change
     log is to show people where to find what was changed.  So you need
     to be specific about what functions you changed; in large
     functions, it's often helpful to indicate where within the
     function the change was.

     On the other hand, once you have shown people where to find the
     change, you need not explain its purpose.  Thus, if you add a new
     function, all you need to say about it is that it is new.  If you
     feel that the purpose needs explaining, it probably does--but the
     explanation will be much more useful if you put it in comments in
     the code.

     If you would like your name to appear in the header line for who
     made the change, send us the header line.

   * When you write the fix, keep in mind that we can't install a
     change that would break other systems.

     People often suggest fixing a problem by changing
     machine-independent files such as `toplev.c' to do something
     special that a particular system needs.  Sometimes it is totally
     obvious that such changes would break GCC for almost all users.
     We can't possibly make a change like that.  At best it might tell
     us how to write another patch that would solve the problem
     acceptably.

     Sometimes people send fixes that _might_ be an improvement in
     general--but it is hard to be sure of this.  It's hard to install
     such changes because we have to study them very carefully.  Of
     course, a good explanation of the reasoning by which you concluded
     the change was correct can help convince us.

     The safest changes are changes to the configuration files for a
     particular machine.  These are safe because they can't create new
     bugs on other machines.

     Please help us keep up with the workload by designing the patch in
     a form that is good to install.


File: gcc.info,  Node: Service,  Next: Contributing,  Prev: Bugs,  Up: Top

9 How To Get Help with GCC
**************************

If you need help installing, using or changing GCC, there are two ways
to find it:

   * Send a message to a suitable network mailing list.  First try
     `gcc-bugs@gcc.gnu.org' or `bug-gcc@gnu.org', and if that brings no
     response, try `gcc@gcc.gnu.org'.

   * Look in the service directory for someone who might help you for a
     fee.  The service directory is found in the file named `SERVICE'
     in the GCC distribution.


File: gcc.info,  Node: Contributing,  Next: VMS,  Prev: Service,  Up: Top

10 Contributing to GCC Development
**********************************

If you would like to help pretest GCC releases to assure they work
well, or if you would like to work on improving GCC, please contact the
maintainers at `gcc@gcc.gnu.org'.  A pretester should be willing to try
to investigate bugs as well as report them.

   If you'd like to work on improvements, please ask for suggested
projects or suggest your own ideas.  If you have already written an
improvement, please tell us about it.  If you have not yet started
work, it is useful to contact `gcc@gcc.gnu.org' before you start; the
maintainers may be able to suggest ways to make your extension fit in
better with the rest of GCC and with other development plans.


File: gcc.info,  Node: VMS,  Next: Portability,  Prev: Contributing,  Up: Top

11 Using GCC on VMS
*******************

Here is how to use GCC on VMS.

* Menu:

* Include Files and VMS::  Where the preprocessor looks for the include files.
* Global Declarations::    How to do globaldef, globalref and globalvalue with
                           GCC.
* VMS Misc::		   Misc information.


File: gcc.info,  Node: Include Files and VMS,  Next: Global Declarations,  Up: VMS

11.1 Include Files and VMS
==========================

Due to the differences between the filesystems of Unix and VMS, GCC
attempts to translate file names in `#include' into names that VMS will
understand.  The basic strategy is to prepend a prefix to the
specification of the include file, convert the whole filename to a VMS
filename, and then try to open the file.  GCC tries various prefixes
one by one until one of them succeeds:

  1. The first prefix is the `GNU_CC_INCLUDE:' logical name: this is
     where GNU C header files are traditionally stored.  If you wish to
     store header files in non-standard locations, then you can assign
     the logical `GNU_CC_INCLUDE' to be a search list, where each
     element of the list is suitable for use with a rooted logical.

  2. The next prefix tried is `SYS$SYSROOT:[SYSLIB.]'.  This is where
     VAX-C header files are traditionally stored.

  3. If the include file specification by itself is a valid VMS
     filename, the preprocessor then uses this name with no prefix in
     an attempt to open the include file.

  4. If the file specification is not a valid VMS filename (i.e. does
     not contain a device or a directory specifier, and contains a `/'
     character), the preprocessor tries to convert it from Unix syntax
     to VMS syntax.

     Conversion works like this: the first directory name becomes a
     device, and the rest of the directories are converted into
     VMS-format directory names.  For example, the name `X11/foobar.h'
     is translated to `X11:[000000]foobar.h' or `X11:foobar.h',
     whichever one can be opened.  This strategy allows you to assign a
     logical name to point to the actual location of the header files.

  5. If none of these strategies succeeds, the `#include' fails.

   Include directives of the form:

     #include foobar

are a common source of incompatibility between VAX-C and GCC.  VAX-C
treats this much like a standard `#include <foobar.h>' directive.  That
is incompatible with the ANSI C behavior implemented by GCC: to expand
the name `foobar' as a macro.  Macro expansion should eventually yield
one of the two standard formats for `#include':

     #include "FILE"
     #include <FILE>

   If you have this problem, the best solution is to modify the source
to convert the `#include' directives to one of the two standard forms.
That will work with either compiler.  If you want a quick and dirty fix,
define the file names as macros with the proper expansion, like this:

     #define stdio <stdio.h>

This will work, as long as the name doesn't conflict with anything else
in the program.

   Another source of incompatibility is that VAX-C assumes that:

     #include "foobar"

is actually asking for the file `foobar.h'.  GCC does not make this
assumption, and instead takes what you ask for literally; it tries to
read the file `foobar'.  The best way to avoid this problem is to
always specify the desired file extension in your include directives.

   GCC for VMS is distributed with a set of include files that is
sufficient to compile most general purpose programs.  Even though the
GCC distribution does not contain header files to define constants and
structures for some VMS system-specific functions, there is no reason
why you cannot use GCC with any of these functions.  You first may have
to generate or create header files, either by using the public domain
utility `UNSDL' (which can be found on a DECUS tape), or by extracting
the relevant modules from one of the system macro libraries, and using
an editor to construct a C header file.

   A `#include' file name cannot contain a DECNET node name.  The
preprocessor reports an I/O error if you attempt to use a node name,
whether explicitly, or implicitly via a logical name.


File: gcc.info,  Node: Global Declarations,  Next: VMS Misc,  Prev: Include Files and VMS,  Up: VMS

11.2 Global Declarations and VMS
================================

GCC does not provide the `globalref', `globaldef' and `globalvalue'
keywords of VAX-C.  You can get the same effect with an obscure feature
of GAS, the GNU assembler.  (This requires GAS version 1.39 or later.)
The following macros allow you to use this feature in a fairly natural
way:

     #ifdef __GNUC__
     #define GLOBALREF(TYPE,NAME)                      \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME)
     #define GLOBALDEF(TYPE,NAME,VALUE)                \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME) \
         = VALUE
     #define GLOBALVALUEREF(TYPE,NAME)                 \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE)           \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)  \
         = {VALUE}
     #else
     #define GLOBALREF(TYPE,NAME) \
       globalref TYPE NAME
     #define GLOBALDEF(TYPE,NAME,VALUE) \
       globaldef TYPE NAME = VALUE
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE) \
       globalvalue TYPE NAME = VALUE
     #define GLOBALVALUEREF(TYPE,NAME) \
       globalvalue TYPE NAME
     #endif

(The `_$$PsectAttributes_GLOBALSYMBOL' prefix at the start of the name
is removed by the assembler, after it has modified the attributes of
the symbol).  These macros are provided in the VMS binaries
distribution in a header file `GNU_HACKS.H'.  An example of the usage
is:

     GLOBALREF (int, ijk);
     GLOBALDEF (int, jkl, 0);

   The macros `GLOBALREF' and `GLOBALDEF' cannot be used
straightforwardly for arrays, since there is no way to insert the array
dimension into the declaration at the right place.  However, you can
declare an array with these macros if you first define a typedef for the
array type, like this:

     typedef int intvector[10];
     GLOBALREF (intvector, foo);

   Array and structure initializers will also break the macros; you can
define the initializer to be a macro of its own, or you can expand the
`GLOBALDEF' macro by hand.  You may find a case where you wish to use
the `GLOBALDEF' macro with a large array, but you are not interested in
explicitly initializing each element of the array.  In such cases you
can use an initializer like: `{0,}', which will initialize the entire
array to `0'.

   A shortcoming of this implementation is that a variable declared with
`GLOBALVALUEREF' or `GLOBALVALUEDEF' is always an array.  For example,
the declaration:

     GLOBALVALUEREF(int, ijk);

declares the variable `ijk' as an array of type `int [1]'.  This is
done because a globalvalue is actually a constant; its "value" is what
the linker would normally consider an address.  That is not how an
integer value works in C, but it is how an array works.  So treating
the symbol as an array name gives consistent results--with the
exception that the value seems to have the wrong type.  *Don't try to
access an element of the array.*  It doesn't have any elements.  The
array "address" may not be the address of actual storage.

   The fact that the symbol is an array may lead to warnings where the
variable is used.  Insert type casts to avoid the warnings.  Here is an
example; it takes advantage of the ANSI C feature allowing macros that
expand to use the same name as the macro itself.

     GLOBALVALUEREF (int, ss$_normal);
     GLOBALVALUEDEF (int, xyzzy,123);
     #ifdef __GNUC__
     #define ss$_normal ((int) ss$_normal)
     #define xyzzy ((int) xyzzy)
     #endif

   Don't use `globaldef' or `globalref' with a variable whose type is
an enumeration type; this is not implemented.  Instead, make the
variable an integer, and use a `globalvaluedef' for each of the
enumeration values.  An example of this would be:

     #ifdef __GNUC__
     GLOBALDEF (int, color, 0);
     GLOBALVALUEDEF (int, RED, 0);
     GLOBALVALUEDEF (int, BLUE, 1);
     GLOBALVALUEDEF (int, GREEN, 3);
     #else
     enum globaldef color {RED, BLUE, GREEN = 3};
     #endif


File: gcc.info,  Node: VMS Misc,  Prev: Global Declarations,  Up: VMS

11.3 Other VMS Issues
=====================

GCC automatically arranges for `main' to return 1 by default if you
fail to specify an explicit return value.  This will be interpreted by
VMS as a status code indicating a normal successful completion.
Version 1 of GCC did not provide this default.

   GCC on VMS works only with the GNU assembler, GAS.  You need version
1.37 or later of GAS in order to produce value debugging information for
the VMS debugger.  Use the ordinary VMS linker with the object files
produced by GAS.

   Under previous versions of GCC, the generated code would occasionally
give strange results when linked to the sharable `VAXCRTL' library.
Now this should work.

   A caveat for use of `const' global variables: the `const' modifier
must be specified in every external declaration of the variable in all
of the source files that use that variable.  Otherwise the linker will
issue warnings about conflicting attributes for the variable.  Your
program will still work despite the warnings, but the variable will be
placed in writable storage.

   Although the VMS linker does distinguish between upper and lower case
letters in global symbols, most VMS compilers convert all such symbols
into upper case and most run-time library routines also have upper case
names.  To be able to reliably call such routines, GCC (by means of the
assembler GAS) converts global symbols into upper case like other VMS
compilers.  However, since the usual practice in C is to distinguish
case, GCC (via GAS) tries to preserve usual C behavior by augmenting
each name that is not all lower case.  This means truncating the name
to at most 23 characters and then adding more characters at the end
which encode the case pattern of those 23.   Names which contain at
least one dollar sign are an exception; they are converted directly into
upper case without augmentation.

   Name augmentation yields bad results for programs that use
precompiled libraries (such as Xlib) which were generated by another
compiler.  You can use the compiler option `/NOCASE_HACK' to inhibit
augmentation; it makes external C functions and variables
case-independent as is usual on VMS.  Alternatively, you could write
all references to the functions and variables in such libraries using
lower case; this will work on VMS, but is not portable to other
systems.  The compiler option `/NAMES' also provides control over
global name handling.

   Function and variable names are handled somewhat differently with GNU
C++.  The GNU C++ compiler performs "name mangling" on function names,
which means that it adds information to the function name to describe
the data types of the arguments that the function takes.  One result of
this is that the name of a function can become very long.  Since the
VMS linker only recognizes the first 31 characters in a name, special
action is taken to ensure that each function and variable has a unique
name that can be represented in 31 characters.

   If the name (plus a name augmentation, if required) is less than 32
characters in length, then no special action is performed.  If the name
is longer than 31 characters, the assembler (GAS) will generate a hash
string based upon the function name, truncate the function name to 23
characters, and append the hash string to the truncated name.  If the
`/VERBOSE' compiler option is used, the assembler will print both the
full and truncated names of each symbol that is truncated.

   The `/NOCASE_HACK' compiler option should not be used when you are
compiling programs that use libg++.  libg++ has several instances of
objects (i.e.  `Filebuf' and `filebuf') which become indistinguishable
in a case-insensitive environment.  This leads to cases where you need
to inhibit augmentation selectively (if you were using libg++ and Xlib
in the same program, for example).  There is no special feature for
doing this, but you can get the result by defining a macro for each
mixed case symbol for which you wish to inhibit augmentation.  The
macro should expand into the lower case equivalent of itself.  For
example:

     #define StuDlyCapS studlycaps

   These macro definitions can be placed in a header file to minimize
the number of changes to your source code.


File: gcc.info,  Node: Portability,  Next: Interface,  Prev: VMS,  Up: Top

12 GCC and Portability
**********************

The main goal of GCC was to make a good, fast compiler for machines in
the class that the GNU system aims to run on: 32-bit machines that
address 8-bit bytes and have several general registers.  Elegance,
theoretical power and simplicity are only secondary.

   GCC gets most of the information about the target machine from a
machine description which gives an algebraic formula for each of the
machine's instructions.  This is a very clean way to describe the
target.  But when the compiler needs information that is difficult to
express in this fashion, I have not hesitated to define an ad-hoc
parameter to the machine description.  The purpose of portability is to
reduce the total work needed on the compiler; it was not of interest
for its own sake.

   GCC does not contain machine dependent code, but it does contain code
that depends on machine parameters such as endianness (whether the most
significant byte has the highest or lowest address of the bytes in a
word) and the availability of autoincrement addressing.  In the
RTL-generation pass, it is often necessary to have multiple strategies
for generating code for a particular kind of syntax tree, strategies
that are usable for different combinations of parameters.  Often I have
not tried to address all possible cases, but only the common ones or
only the ones that I have encountered.  As a result, a new target may
require additional strategies.  You will know if this happens because
the compiler will call `abort'.  Fortunately, the new strategies can be
added in a machine-independent fashion, and will affect only the target
machines that need them.


File: gcc.info,  Node: Interface,  Next: Passes,  Prev: Portability,  Up: Top

13 Interfacing to GCC Output
****************************

GCC is normally configured to use the same function calling convention
normally in use on the target system.  This is done with the
machine-description macros described (*note Target Macros::).

   However, returning of structure and union values is done differently
on some target machines.  As a result, functions compiled with PCC
returning such types cannot be called from code compiled with GCC, and
vice versa.  This does not cause trouble often because few Unix library
routines return structures or unions.

   GCC code returns structures and unions that are 1, 2, 4 or 8 bytes
long in the same registers used for `int' or `double' return values.
(GCC typically allocates variables of such types in registers also.)
Structures and unions of other sizes are returned by storing them into
an address passed by the caller (usually in a register).  The
machine-description macros `STRUCT_VALUE' and `STRUCT_INCOMING_VALUE'
tell GCC where to pass this address.

   By contrast, PCC on most target machines returns structures and
unions of any size by copying the data into an area of static storage,
and then returning the address of that storage as if it were a pointer
value.  The caller must copy the data from that memory area to the
place where the value is wanted.  This is slower than the method used
by GCC, and fails to be reentrant.

   On some target machines, such as RISC machines and the 80386, the
standard system convention is to pass to the subroutine the address of
where to return the value.  On these machines, GCC has been configured
to be compatible with the standard compiler, when this method is used.
It may not be compatible for structures of 1, 2, 4 or 8 bytes.

   GCC uses the system's standard convention for passing arguments.  On
some machines, the first few arguments are passed in registers; in
others, all are passed on the stack.  It would be possible to use
registers for argument passing on any machine, and this would probably
result in a significant speedup.  But the result would be complete
incompatibility with code that follows the standard convention.  So this
change is practical only if you are switching to GCC as the sole C
compiler for the system.  We may implement register argument passing on
certain machines once we have a complete GNU system so that we can
compile the libraries with GCC.

   On some machines (particularly the Sparc), certain types of arguments
are passed "by invisible reference".  This means that the value is
stored in memory, and the address of the memory location is passed to
the subroutine.

   If you use `longjmp', beware of automatic variables.  ANSI C says
that automatic variables that are not declared `volatile' have undefined
values after a `longjmp'.  And this is all GCC promises to do, because
it is very difficult to restore register variables correctly, and one
of GCC's features is that it can put variables in registers without
your asking it to.

   If you want a variable to be unaltered by `longjmp', and you don't
want to write `volatile' because old C compilers don't accept it, just
take the address of the variable.  If a variable's address is ever
taken, even if just to compute it and ignore it, then the variable
cannot go in a register:

     {
       int careful;
       &careful;
       ...
     }

   Code compiled with GCC may call certain library routines.  Most of
them handle arithmetic for which there are no instructions.  This
includes multiply and divide on some machines, and floating point
operations on any machine for which floating point support is disabled
with `-msoft-float'.  Some standard parts of the C library, such as
`bcopy' or `memcpy', are also called automatically.  The usual function
call interface is used for calling the library routines.

   These library routines should be defined in the library `libgcc.a',
which GCC automatically searches whenever it links a program.  On
machines that have multiply and divide instructions, if hardware
floating point is in use, normally `libgcc.a' is not needed, but it is
searched just in case.

   Each arithmetic function is defined in `libgcc1.c' to use the
corresponding C arithmetic operator.  As long as the file is compiled
with another C compiler, which supports all the C arithmetic operators,
this file will work portably.  However, `libgcc1.c' does not work if
compiled with GCC, because each arithmetic function would compile into
a call to itself!


File: gcc.info,  Node: Passes,  Next: RTL,  Prev: Interface,  Up: Top

14 Passes and Files of the Compiler
***********************************

The overall control structure of the compiler is in `toplev.c'.  This
file is responsible for initialization, decoding arguments, opening and
closing files, and sequencing the passes.

   The parsing pass is invoked only once, to parse the entire input.
The RTL intermediate code for a function is generated as the function
is parsed, a statement at a time.  Each statement is read in as a
syntax tree and then converted to RTL; then the storage for the tree
for the statement is reclaimed.  Storage for types (and the expressions
for their sizes), declarations, and a representation of the binding
contours and how they nest, remain until the function is finished being
compiled; these are all needed to output the debugging information.

   Each time the parsing pass reads a complete function definition or
top-level declaration, it calls either the function
`rest_of_compilation', or the function `rest_of_decl_compilation' in
`toplev.c', which are responsible for all further processing necessary,
ending with output of the assembler language.  All other compiler
passes run, in sequence, within `rest_of_compilation'.  When that
function returns from compiling a function definition, the storage used
for that function definition's compilation is entirely freed, unless it
is an inline function (*note An Inline Function is As Fast As a Macro:
Inline.).

   Here is a list of all the passes of the compiler and their source
files.  Also included is a description of where debugging dumps can be
requested with `-d' options.

   * Parsing.  This pass reads the entire text of a function definition,
     constructing partial syntax trees.  This and RTL generation are no
     longer truly separate passes (formerly they were), but it is
     easier to think of them as separate.

     The tree representation does not entirely follow C syntax, because
     it is intended to support other languages as well.

     Language-specific data type analysis is also done in this pass,
     and every tree node that represents an expression has a data type
     attached.  Variables are represented as declaration nodes.

     Constant folding and some arithmetic simplifications are also done
     during this pass.

     The language-independent source files for parsing are
     `stor-layout.c', `fold-const.c', and `tree.c'.  There are also
     header files `tree.h' and `tree.def' which define the format of
     the tree representation.

     The source files to parse C are `c-parse.in', `c-decl.c',
     `c-typeck.c', `c-aux-info.c', `c-convert.c', and `c-lang.c' along
     with header files `c-lex.h', and `c-tree.h'.

     The source files for parsing C++ are `cp-parse.y', `cp-class.c',
     `cp-cvt.c', `cp-decl.c', `cp-decl2.c', `cp-dem.c', `cp-except.c',
     `cp-expr.c', `cp-init.c', `cp-lex.c', `cp-method.c', `cp-ptree.c',
     `cp-search.c', `cp-tree.c', `cp-type2.c', and `cp-typeck.c', along
     with header files `cp-tree.def', `cp-tree.h', and `cp-decl.h'.

     The special source files for parsing Objective C are
     `objc-parse.y', `objc-actions.c', `objc-tree.def', and
     `objc-actions.h'.  Certain C-specific files are used for this as
     well.

     The file `c-common.c' is also used for all of the above languages.

   * RTL generation.  This is the conversion of syntax tree into RTL
     code.  It is actually done statement-by-statement during parsing,
     but for most purposes it can be thought of as a separate pass.

     This is where the bulk of target-parameter-dependent code is found,
     since often it is necessary for strategies to apply only when
     certain standard kinds of instructions are available.  The purpose
     of named instruction patterns is to provide this information to
     the RTL generation pass.

     Optimization is done in this pass for `if'-conditions that are
     comparisons, boolean operations or conditional expressions.  Tail
     recursion is detected at this time also.  Decisions are made about
     how best to arrange loops and how to output `switch' statements.

     The source files for RTL generation include `stmt.c', `calls.c',
     `expr.c', `explow.c', `expmed.c', `function.c', `optabs.c' and
     `emit-rtl.c'.  Also, the file `insn-emit.c', generated from the
     machine description by the program `genemit', is used in this
     pass.  The header file `expr.h' is used for communication within
     this pass.

     The header files `insn-flags.h' and `insn-codes.h', generated from
     the machine description by the programs `genflags' and `gencodes',
     tell this pass which standard names are available for use and
     which patterns correspond to them.

     Aside from debugging information output, none of the following
     passes refers to the tree structure representation of the function
     (only part of which is saved).

     The decision of whether the function can and should be expanded
     inline in its subsequent callers is made at the end of rtl
     generation.  The function must meet certain criteria, currently
     related to the size of the function and the types and number of
     parameters it has.  Note that this function may contain loops,
     recursive calls to itself (tail-recursive functions can be
     inlined!), gotos, in short, all constructs supported by GCC.  The
     file `integrate.c' contains the code to save a function's rtl for
     later inlining and to inline that rtl when the function is called.
     The header file `integrate.h' is also used for this purpose.

     The option `-dr' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.rtl' to
     the input file name.

   * Jump optimization.  This pass simplifies jumps to the following
     instruction, jumps across jumps, and jumps to jumps.  It deletes
     unreferenced labels and unreachable code, except that unreachable
     code that contains a loop is not recognized as unreachable in this
     pass.  (Such loops are deleted later in the basic block analysis.)
     It also converts some code originally written with jumps into
     sequences of instructions that directly set values from the
     results of comparisons, if the machine has such instructions.

     Jump optimization is performed two or three times.  The first time
     is immediately following RTL generation.  The second time is after
     CSE, but only if CSE says repeated jump optimization is needed.
     The last time is right before the final pass.  That time,
     cross-jumping and deletion of no-op move instructions are done
     together with the optimizations described above.

     The source file of this pass is `jump.c'.

     The option `-dj' causes a debugging dump of the RTL code after
     this pass is run for the first time.  This dump file's name is
     made by appending `.jump' to the input file name.

   * Register scan.  This pass finds the first and last use of each
     register, as a guide for common subexpression elimination.  Its
     source is in `regclass.c'.

   * Jump threading.  This pass detects a condition jump that branches
     to an identical or inverse test.  Such jumps can be `threaded'
     through the second conditional test.  The source code for this
     pass is in `jump.c'.  This optimization is only performed if
     `-fthread-jumps' is enabled.

   * Common subexpression elimination.  This pass also does constant
     propagation.  Its source file is `cse.c'.  If constant propagation
     causes conditional jumps to become unconditional or to become
     no-ops, jump optimization is run again when CSE is finished.

     The option `-ds' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.cse' to
     the input file name.

   * Global common subexpression elimination.  This pass performs GCSE
     using Morel-Renvoise Partial Redundancy Elimination, with the
     exception that it does not try to move invariants out of loops -
     that is left to the loop optimization pass.  This pass also
     performs global constant and copy propagation.

     The source file for this pass is gcse.c.

     The option `-dG' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.gcse' to
     the input file name.

   * Loop optimization.  This pass moves constant expressions out of
     loops, and optionally does strength-reduction and loop unrolling
     as well.  Its source files are `loop.c' and `unroll.c', plus the
     header `loop.h' used for communication between them.  Loop
     unrolling uses some functions in `integrate.c' and the header
     `integrate.h'.

     The option `-dL' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.loop' to
     the input file name.

   * If `-frerun-cse-after-loop' was enabled, a second common
     subexpression elimination pass is performed after the loop
     optimization pass.  Jump threading is also done again at this time
     if it was specified.

     The option `-dt' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.cse2' to
     the input file name.

   * Stupid register allocation is performed at this point in a
     nonoptimizing compilation.  It does a little data flow analysis as
     well.  When stupid register allocation is in use, the next pass
     executed is the reloading pass; the others in between are skipped.
     The source file is `stupid.c'.

   * Data flow analysis (`flow.c').  This pass divides the program into
     basic blocks (and in the process deletes unreachable loops); then
     it computes which pseudo-registers are live at each point in the
     program, and makes the first instruction that uses a value point at
     the instruction that computed the value.

     This pass also deletes computations whose results are never used,
     and combines memory references with add or subtract instructions
     to make autoincrement or autodecrement addressing.

     The option `-df' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.flow' to
     the input file name.  If stupid register allocation is in use, this
     dump file reflects the full results of such allocation.

   * Instruction combination (`combine.c').  This pass attempts to
     combine groups of two or three instructions that are related by
     data flow into single instructions.  It combines the RTL
     expressions for the instructions by substitution, simplifies the
     result using algebra, and then attempts to match the result
     against the machine description.

     The option `-dc' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.combine'
     to the input file name.

   * Register movement (`regmove.c'). This pass looks for cases where
     matching constraints would force an instruction to need a reload,
     and this reload would be a register to register move.  It them
     attempts to change the registers used by the instruction to avoid
     the move instruction.

     The option `-dN' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.regmove'
     to the input file name.

   * Instruction scheduling (`sched.c').  This pass looks for
     instructions whose output will not be available by the time that
     it is used in subsequent instructions.  (Memory loads and floating
     point instructions often have this behavior on RISC machines).  It
     re-orders instructions within a basic block to try to separate the
     definition and use of items that otherwise would cause pipeline
     stalls.

     Instruction scheduling is performed twice.  The first time is
     immediately after instruction combination and the second is
     immediately after reload.

     The option `-dS' causes a debugging dump of the RTL code after this
     pass is run for the first time.  The dump file's name is made by
     appending `.sched' to the input file name.

   * Register class preferencing.  The RTL code is scanned to find out
     which register class is best for each pseudo register.  The source
     file is `regclass.c'.

   * Local register allocation (`local-alloc.c').  This pass allocates
     hard registers to pseudo registers that are used only within one
     basic block.  Because the basic block is linear, it can use fast
     and powerful techniques to do a very good job.

     The option `-dl' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.lreg' to
     the input file name.

   * Global register allocation (`global.c').  This pass allocates hard
     registers for the remaining pseudo registers (those whose life
     spans are not contained in one basic block).

   * Reloading.  This pass renumbers pseudo registers with the hardware
     registers numbers they were allocated.  Pseudo registers that did
     not get hard registers are replaced with stack slots.  Then it
     finds instructions that are invalid because a value has failed to
     end up in a register, or has ended up in a register of the wrong
     kind.  It fixes up these instructions by reloading the
     problematical values temporarily into registers.  Additional
     instructions are generated to do the copying.

     The reload pass also optionally eliminates the frame pointer and
     inserts instructions to save and restore call-clobbered registers
     around calls.

     Source files are `reload.c' and `reload1.c', plus the header
     `reload.h' used for communication between them.

     The option `-dg' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.greg' to
     the input file name.

   * Instruction scheduling is repeated here to try to avoid pipeline
     stalls due to memory loads generated for spilled pseudo registers.

     The option `-dR' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.sched2'
     to the input file name.

   * Jump optimization is repeated, this time including cross-jumping
     and deletion of no-op move instructions.

     The option `-dJ' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.jump2' to
     the input file name.

   * Delayed branch scheduling.  This optional pass attempts to find
     instructions that can go into the delay slots of other
     instructions, usually jumps and calls.  The source file name is
     `reorg.c'.

     The option `-dd' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.dbr' to
     the input file name.

   * Conversion from usage of some hard registers to usage of a register
     stack may be done at this point.  Currently, this is supported only
     for the floating-point registers of the Intel 80387 coprocessor.
     The source file name is `reg-stack.c'.

     The options `-dk' causes a debugging dump of the RTL code after
     this pass.  This dump file's name is made by appending `.stack' to
     the input file name.

   * Final.  This pass outputs the assembler code for the function.  It
     is also responsible for identifying spurious test and compare
     instructions.  Machine-specific peephole optimizations are
     performed at the same time.  The function entry and exit sequences
     are generated directly as assembler code in this pass; they never
     exist as RTL.

     The source files are `final.c' plus `insn-output.c'; the latter is
     generated automatically from the machine description by the tool
     `genoutput'.  The header file `conditions.h' is used for
     communication between these files.

   * Debugging information output.  This is run after final because it
     must output the stack slot offsets for pseudo registers that did
     not get hard registers.  Source files are `dbxout.c' for DBX
     symbol table format, `sdbout.c' for SDB symbol table format, and
     `dwarfout.c' for DWARF symbol table format.

   Some additional files are used by all or many passes:

   * Every pass uses `machmode.def' and `machmode.h' which define the
     machine modes.

   * Several passes use `real.h', which defines the default
     representation of floating point constants and how to operate on
     them.

   * All the passes that work with RTL use the header files `rtl.h' and
     `rtl.def', and subroutines in file `rtl.c'.  The tools `gen*' also
     use these files to read and work with the machine description RTL.

   * Several passes refer to the header file `insn-config.h' which
     contains a few parameters (C macro definitions) generated
     automatically from the machine description RTL by the tool
     `genconfig'.

   * Several passes use the instruction recognizer, which consists of
     `recog.c' and `recog.h', plus the files `insn-recog.c' and
     `insn-extract.c' that are generated automatically from the machine
     description by the tools `genrecog' and `genextract'.

   * Several passes use the header files `regs.h' which defines the
     information recorded about pseudo register usage, and
     `basic-block.h' which defines the information recorded about basic
     blocks.

   * `hard-reg-set.h' defines the type `HARD_REG_SET', a bit-vector
     with a bit for each hard register, and some macros to manipulate
     it.  This type is just `int' if the machine has few enough hard
     registers; otherwise it is an array of `int' and some of the
     macros expand into loops.

   * Several passes use instruction attributes.  A definition of the
     attributes defined for a particular machine is in file
     `insn-attr.h', which is generated from the machine description by
     the program `genattr'.  The file `insn-attrtab.c' contains
     subroutines to obtain the attribute values for insns.  It is
     generated from the machine description by the program `genattrtab'.


File: gcc.info,  Node: RTL,  Next: Machine Desc,  Prev: Passes,  Up: Top

15 RTL Representation
*********************

Most of the work of the compiler is done on an intermediate
representation called register transfer language.  In this language,
the instructions to be output are described, pretty much one by one, in
an algebraic form that describes what the instruction does.

   RTL is inspired by Lisp lists.  It has both an internal form, made
up of structures that point at other structures, and a textual form
that is used in the machine description and in printed debugging dumps.
The textual form uses nested parentheses to indicate the pointers in
the internal form.

* Menu:

* RTL Objects::       Expressions vs vectors vs strings vs integers.
* RTL Classes::       Categories of RTL expresion objects, and their structure.
* Accessors::         Macros to access expression operands or vector elts.
* Flags::             Other flags in an RTL expression.
* Machine Modes::     Describing the size and format of a datum.
* Constants::         Expressions with constant values.
* Regs and Memory::   Expressions representing register contents or memory.
* Arithmetic::        Expressions representing arithmetic on other expressions.
* Comparisons::       Expressions representing comparison of expressions.
* Bit Fields::        Expressions representing bitfields in memory or reg.
* Conversions::       Extending, truncating, floating or fixing.
* RTL Declarations::  Declaring volatility, constancy, etc.
* Side Effects::      Expressions for storing in registers, etc.
* Incdec::            Embedded side-effects for autoincrement addressing.
* Assembler::         Representing `asm' with operands.
* Insns::             Expression types for entire insns.
* Calls::             RTL representation of function call insns.
* Sharing::           Some expressions are unique; others *must* be copied.
* Reading RTL::       Reading textual RTL from a file.


File: gcc.info,  Node: RTL Objects,  Next: RTL Classes,  Prev: RTL,  Up: RTL

15.1 RTL Object Types
=====================

RTL uses five kinds of objects: expressions, integers, wide integers,
strings and vectors.  Expressions are the most important ones.  An RTL
expression ("RTX", for short) is a C structure, but it is usually
referred to with a pointer; a type that is given the typedef name `rtx'.

   An integer is simply an `int'; their written form uses decimal
digits.  A wide integer is an integral object whose type is
`HOST_WIDE_INT' (*note Config::); their written form uses decimal
digits.

   A string is a sequence of characters.  In core it is represented as a
`char *' in usual C fashion, and it is written in C syntax as well.
However, strings in RTL may never be null.  If you write an empty
string in a machine description, it is represented in core as a null
pointer rather than as a pointer to a null character.  In certain
contexts, these null pointers instead of strings are valid.  Within RTL
code, strings are most commonly found inside `symbol_ref' expressions,
but they appear in other contexts in the RTL expressions that make up
machine descriptions.

   A vector contains an arbitrary number of pointers to expressions.
The number of elements in the vector is explicitly present in the
vector.  The written form of a vector consists of square brackets
(`[...]') surrounding the elements, in sequence and with whitespace
separating them.  Vectors of length zero are not created; null pointers
are used instead.

   Expressions are classified by "expression codes" (also called RTX
codes).  The expression code is a name defined in `rtl.def', which is
also (in upper case) a C enumeration constant.  The possible expression
codes and their meanings are machine-independent.  The code of an RTX
can be extracted with the macro `GET_CODE (X)' and altered with
`PUT_CODE (X, NEWCODE)'.

   The expression code determines how many operands the expression
contains, and what kinds of objects they are.  In RTL, unlike Lisp, you
cannot tell by looking at an operand what kind of object it is.
Instead, you must know from its context--from the expression code of
the containing expression.  For example, in an expression of code
`subreg', the first operand is to be regarded as an expression and the
second operand as an integer.  In an expression of code `plus', there
are two operands, both of which are to be regarded as expressions.  In
a `symbol_ref' expression, there is one operand, which is to be
regarded as a string.

   Expressions are written as parentheses containing the name of the
expression type, its flags and machine mode if any, and then the
operands of the expression (separated by spaces).

   Expression code names in the `md' file are written in lower case,
but when they appear in C code they are written in upper case.  In this
manual, they are shown as follows: `const_int'.

   In a few contexts a null pointer is valid where an expression is
normally wanted.  The written form of this is `(nil)'.


File: gcc.info,  Node: RTL Classes,  Next: Accessors,  Prev: RTL Objects,  Up: RTL

15.2 RTL Classes and Formats
============================

The various expression codes are divided into several "classes", which
are represented by single characters.  You can determine the class of
an RTX code with the macro `GET_RTX_CLASS (CODE)'.  Currently,
`rtx.def' defines these classes:

`o'
     An RTX code that represents an actual object, such as a register
     (`REG') or a memory location (`MEM', `SYMBOL_REF').  Constants and
     basic transforms on objects (`ADDRESSOF', `HIGH', `LO_SUM') are
     also included.  Note that `SUBREG' and `STRICT_LOW_PART' are not
     in this class, but in class `x'.

`<'
     An RTX code for a comparison, such as `NE' or `LT'.

`1'
     An RTX code for a unary arithmetic operation, such as `NEG',
     `NOT', or `ABS'.  This category also includes value extension
     (sign or zero) and conversions between integer and floating point.

`c'
     An RTX code for a commutative binary operation, such as `PLUS' or
     `AND'.  `NE' and `EQ' are comparisons, so they have class `<'.

`2'
     An RTX code for a non-commutative binary operation, such as
     `MINUS', `DIV', or `ASHIFTRT'.

`b'
     An RTX code for a bitfield operation.  Currently only
     `ZERO_EXTRACT' and `SIGN_EXTRACT'.  These have three inputs and
     are lvalues (so they can be used for insertion as well).  *Note
     Bit Fields::.

`3'
     An RTX code for other three input operations.  Currently only
     `IF_THEN_ELSE'.

`i'
     An RTX code for an entire instruction:  `INSN', `JUMP_INSN', and
     `CALL_INSN'. *Note Insns::.

`m'
     An RTX code for something that matches in insns, such as
     `MATCH_DUP'.  These only occur in machine descriptions.

`x'
     All other RTX codes.  This category includes the remaining codes
     used only in machine descriptions (`DEFINE_*', etc.).  It also
     includes all the codes describing side effects (`SET', `USE',
     `CLOBBER', etc.) and the non-insns that may appear on an insn
     chain, such as `NOTE', `BARRIER', and `CODE_LABEL'.

   For each expression type `rtl.def' specifies the number of contained
objects and their kinds, with four possibilities: `e' for expression
(actually a pointer to an expression), `i' for integer, `w' for wide
integer, `s' for string, and `E' for vector of expressions.  The
sequence of letters for an expression code is called its "format".  For
example, the format of `subreg' is `ei'.

   A few other format characters are used occasionally:

`u'
     `u' is equivalent to `e' except that it is printed differently in
     debugging dumps.  It is used for pointers to insns.

`n'
     `n' is equivalent to `i' except that it is printed differently in
     debugging dumps.  It is used for the line number or code number of
     a `note' insn.

`S'
     `S' indicates a string which is optional.  In the RTL objects in
     core, `S' is equivalent to `s', but when the object is read, from
     an `md' file, the string value of this operand may be omitted.  An
     omitted string is taken to be the null string.

`V'
     `V' indicates a vector which is optional.  In the RTL objects in
     core, `V' is equivalent to `E', but when the object is read from
     an `md' file, the vector value of this operand may be omitted.  An
     omitted vector is effectively the same as a vector of no elements.

`0'
     `0' means a slot whose contents do not fit any normal category.
     `0' slots are not printed at all in dumps, and are often used in
     special ways by small parts of the compiler.

   There are macros to get the number of operands and the format of an
expression code:

`GET_RTX_LENGTH (CODE)'
     Number of operands of an RTX of code CODE.

`GET_RTX_FORMAT (CODE)'
     The format of an RTX of code CODE, as a C string.

   Some classes of RTX codes always have the same format.  For example,
it is safe to assume that all comparison operations have format `ee'.

`1'
     All codes of this class have format `e'.

`<'
`c'
`2'
     All codes of these classes have format `ee'.

`b'
`3'
     All codes of these classes have format `eee'.

`i'
     All codes of this class have formats that begin with `iuueiee'.
     *Note Insns::.  Note that not all RTL objects linked onto an insn
     chain are of class `i'.

`o'
`m'
`x'
     You can make no assumptions about the format of these codes.


File: gcc.info,  Node: Accessors,  Next: Flags,  Prev: RTL Classes,  Up: RTL

15.3 Access to Operands
=======================

Operands of expressions are accessed using the macros `XEXP', `XINT',
`XWINT' and `XSTR'.  Each of these macros takes two arguments: an
expression-pointer (RTX) and an operand number (counting from zero).
Thus,

     XEXP (X, 2)

accesses operand 2 of expression X, as an expression.

     XINT (X, 2)

accesses the same operand as an integer.  `XSTR', used in the same
fashion, would access it as a string.

   Any operand can be accessed as an integer, as an expression or as a
string.  You must choose the correct method of access for the kind of
value actually stored in the operand.  You would do this based on the
expression code of the containing expression.  That is also how you
would know how many operands there are.

   For example, if X is a `subreg' expression, you know that it has two
operands which can be correctly accessed as `XEXP (X, 0)' and `XINT (X,
1)'.  If you did `XINT (X, 0)', you would get the address of the
expression operand but cast as an integer; that might occasionally be
useful, but it would be cleaner to write `(int) XEXP (X, 0)'.  `XEXP
(X, 1)' would also compile without error, and would return the second,
integer operand cast as an expression pointer, which would probably
result in a crash when accessed.  Nothing stops you from writing `XEXP
(X, 28)' either, but this will access memory past the end of the
expression with unpredictable results.

   Access to operands which are vectors is more complicated.  You can
use the macro `XVEC' to get the vector-pointer itself, or the macros
`XVECEXP' and `XVECLEN' to access the elements and length of a vector.

`XVEC (EXP, IDX)'
     Access the vector-pointer which is operand number IDX in EXP.

`XVECLEN (EXP, IDX)'
     Access the length (number of elements) in the vector which is in
     operand number IDX in EXP.  This value is an `int'.

`XVECEXP (EXP, IDX, ELTNUM)'
     Access element number ELTNUM in the vector which is in operand
     number IDX in EXP.  This value is an RTX.

     It is up to you to make sure that ELTNUM is not negative and is
     less than `XVECLEN (EXP, IDX)'.

   All the macros defined in this section expand into lvalues and
therefore can be used to assign the operands, lengths and vector
elements as well as to access them.


File: gcc.info,  Node: Flags,  Next: Machine Modes,  Prev: Accessors,  Up: RTL

15.4 Flags in an RTL Expression
===============================

RTL expressions contain several flags (one-bit bitfields) and other
values that are used in certain types of expression.  Most often they
are accessed with the following macros:

`MEM_VOLATILE_P (X)'
     In `mem' expressions, nonzero for volatile memory references.
     Stored in the `volatil' field and printed as `/v'.

`MEM_IN_STRUCT_P (X)'
     In `mem' expressions, nonzero for reference to an entire structure,
     union or array, or to a component of one.  Zero for references to a
     scalar variable or through a pointer to a scalar.  Stored in the
     `in_struct' field and printed as `/s'.  If both this flag and
     MEM_SCALAR_P are clear, then we don't know whether this MEM is in a
     structure or not.  Both flags should never be simultaneously set.

`MEM_SCALAR_P (X)'
     In `mem' expressions, nonzero for reference to a scalar known not
     to be a member of a structure, union, or array.  Zero for such
     references and for indirections through pointers, even pointers
     pointing to scalar types.  If both this flag and MEM_STRUCT_P are
     clear, then we don't know whether this MEM is in a structure or
     not.  Both flags should never be simultaneously set.

`MEM_ALIAS_SET (X)'
     In `mem' expressions, the alias set to which X belongs.  If zero,
     X is not in any alias set, and may alias anything.  If nonzero, X
     may only alias objects in the same alias set.  This value is set
     (in a language-specific manner) by the front-end.  This field is
     not a bit-field; it is in an integer, found as the second argument
     to the `mem'.

`REG_LOOP_TEST_P'
     In `reg' expressions, nonzero if this register's entire life is
     contained in the exit test code for some loop.  Stored in the
     `in_struct' field and printed as `/s'.

`REG_USERVAR_P (X)'
     In a `reg', nonzero if it corresponds to a variable present in the
     user's source code.  Zero for temporaries generated internally by
     the compiler.  Stored in the `volatil' field and printed as `/v'.

`REG_FUNCTION_VALUE_P (X)'
     Nonzero in a `reg' if it is the place in which this function's
     value is going to be returned.  (This happens only in a hard
     register.)  Stored in the `integrated' field and printed as `/i'.

     The same hard register may be used also for collecting the values
     of functions called by this one, but `REG_FUNCTION_VALUE_P' is zero
     in this kind of use.

`SUBREG_PROMOTED_VAR_P'
     Nonzero in a `subreg' if it was made when accessing an object that
     was promoted to a wider mode in accord with the `PROMOTED_MODE'
     machine description macro (*note Storage Layout::).  In this case,
     the mode of the `subreg' is the declared mode of the object and
     the mode of `SUBREG_REG' is the mode of the register that holds
     the object.  Promoted variables are always either sign- or
     zero-extended to the wider mode on every assignment.  Stored in
     the `in_struct' field and printed as `/s'.

`SUBREG_PROMOTED_UNSIGNED_P'
     Nonzero in a `subreg' that has `SUBREG_PROMOTED_VAR_P' nonzero if
     the object being referenced is kept zero-extended and zero if it
     is kept sign-extended.  Stored in the `unchanging' field and
     printed as `/u'.

`RTX_UNCHANGING_P (X)'
     Nonzero in a `reg' or `mem' if the value is not changed.  (This
     flag is not set for memory references via pointers to constants.
     Such pointers only guarantee that the object will not be changed
     explicitly by the current function.  The object might be changed by
     other functions or by aliasing.)  Stored in the `unchanging' field
     and printed as `/u'.

`RTX_INTEGRATED_P (INSN)'
     Nonzero in an insn if it resulted from an in-line function call.
     Stored in the `integrated' field and printed as `/i'.

`RTX_FRAME_RELATED_P (X)'
     Nonzero in an insn or expression which is part of a function
     prologue and sets the stack pointer, sets the frame pointer, or
     saves a register. This flag is required for exception handling
     support on targets with RTL prologues.

`SYMBOL_REF_USED (X)'
     In a `symbol_ref', indicates that X has been used.  This is
     normally only used to ensure that X is only declared external
     once.  Stored in the `used' field.

`SYMBOL_REF_FLAG (X)'
     In a `symbol_ref', this is used as a flag for machine-specific
     purposes.  Stored in the `volatil' field and printed as `/v'.

`LABEL_OUTSIDE_LOOP_P'
     In `label_ref' expressions, nonzero if this is a reference to a
     label that is outside the innermost loop containing the reference
     to the label.  Stored in the `in_struct' field and printed as `/s'.

`INSN_DELETED_P (INSN)'
     In an insn, nonzero if the insn has been deleted.  Stored in the
     `volatil' field and printed as `/v'.

`INSN_ANNULLED_BRANCH_P (INSN)'
     In an `insn' in the delay slot of a branch insn, indicates that an
     annulling branch should be used.  See the discussion under
     `sequence' below.  Stored in the `unchanging' field and printed as
     `/u'.

`INSN_FROM_TARGET_P (INSN)'
     In an `insn' in a delay slot of a branch, indicates that the insn
     is from the target of the branch.  If the branch insn has
     `INSN_ANNULLED_BRANCH_P' set, this insn will only be executed if
     the branch is taken.  For annulled branches with
     `INSN_FROM_TARGET_P' clear, the insn will be executed only if the
     branch is not taken.  When `INSN_ANNULLED_BRANCH_P' is not set,
     this insn will always be executed.  Stored in the `in_struct'
     field and printed as `/s'.

`CONSTANT_POOL_ADDRESS_P (X)'
     Nonzero in a `symbol_ref' if it refers to part of the current
     function's "constants pool".  These are addresses close to the
     beginning of the function, and GNU CC assumes they can be addressed
     directly (perhaps with the help of base registers).  Stored in the
     `unchanging' field and printed as `/u'.

`CONST_CALL_P (X)'
     In a `call_insn', indicates that the insn represents a call to a
     const function.  Stored in the `unchanging' field and printed as
     `/u'.

`LABEL_PRESERVE_P (X)'
     In a `code_label', indicates that the label can never be deleted.
     Labels referenced by a non-local goto will have this bit set.
     Stored in the `in_struct' field and printed as `/s'.

`SCHED_GROUP_P (INSN)'
     During instruction scheduling, in an insn, indicates that the
     previous insn must be scheduled together with this insn.  This is
     used to ensure that certain groups of instructions will not be
     split up by the instruction scheduling pass, for example, `use'
     insns before a `call_insn' may not be separated from the
     `call_insn'.  Stored in the `in_struct' field and printed as `/s'.

   These are the fields which the above macros refer to:

`used'
     Normally, this flag is used only momentarily, at the end of RTL
     generation for a function, to count the number of times an
     expression appears in insns.  Expressions that appear more than
     once are copied, according to the rules for shared structure
     (*note Sharing::).

     In a `symbol_ref', it indicates that an external declaration for
     the symbol has already been written.

     In a `reg', it is used by the leaf register renumbering code to
     ensure that each register is only renumbered once.

`volatil'
     This flag is used in `mem', `symbol_ref' and `reg' expressions and
     in insns.  In RTL dump files, it is printed as `/v'.

     In a `mem' expression, it is 1 if the memory reference is volatile.
     Volatile memory references may not be deleted, reordered or
     combined.

     In a `symbol_ref' expression, it is used for machine-specific
     purposes.

     In a `reg' expression, it is 1 if the value is a user-level
     variable.  0 indicates an internal compiler temporary.

     In an insn, 1 means the insn has been deleted.

`in_struct'
     In `mem' expressions, it is 1 if the memory datum referred to is
     all or part of a structure or array; 0 if it is (or might be) a
     scalar variable.  A reference through a C pointer has 0 because
     the pointer might point to a scalar variable.  This information
     allows the compiler to determine something about possible cases of
     aliasing.

     In an insn in the delay slot of a branch, 1 means that this insn
     is from the target of the branch.

     During instruction scheduling, in an insn, 1 means that this insn
     must be scheduled as part of a group together with the previous
     insn.

     In `reg' expressions, it is 1 if the register has its entire life
     contained within the test expression of some loop.

     In `subreg' expressions, 1 means that the `subreg' is accessing an
     object that has had its mode promoted from a wider mode.

     In `label_ref' expressions, 1 means that the referenced label is
     outside the innermost loop containing the insn in which the
     `label_ref' was found.

     In `code_label' expressions, it is 1 if the label may never be
     deleted.  This is used for labels which are the target of
     non-local gotos.

     In an RTL dump, this flag is represented as `/s'.

`unchanging'
     In `reg' and `mem' expressions, 1 means that the value of the
     expression never changes.

     In `subreg' expressions, it is 1 if the `subreg' references an
     unsigned object whose mode has been promoted to a wider mode.

     In an insn, 1 means that this is an annulling branch.

     In a `symbol_ref' expression, 1 means that this symbol addresses
     something in the per-function constants pool.

     In a `call_insn', 1 means that this instruction is a call to a
     const function.

     In an RTL dump, this flag is represented as `/u'.

`integrated'
     In some kinds of expressions, including insns, this flag means the
     rtl was produced by procedure integration.

     In a `reg' expression, this flag indicates the register containing
     the value to be returned by the current function.  On machines
     that pass parameters in registers, the same register number may be
     used for parameters as well, but this flag is not set on such uses.


File: gcc.info,  Node: Machine Modes,  Next: Constants,  Prev: Flags,  Up: RTL

15.5 Machine Modes
==================

A machine mode describes a size of data object and the representation
used for it.  In the C code, machine modes are represented by an
enumeration type, `enum machine_mode', defined in `machmode.def'.  Each
RTL expression has room for a machine mode and so do certain kinds of
tree expressions (declarations and types, to be precise).

   In debugging dumps and machine descriptions, the machine mode of an
RTL expression is written after the expression code with a colon to
separate them.  The letters `mode' which appear at the end of each
machine mode name are omitted.  For example, `(reg:SI 38)' is a `reg'
expression with machine mode `SImode'.  If the mode is `VOIDmode', it
is not written at all.

   Here is a table of machine modes.  The term "byte" below refers to an
object of `BITS_PER_UNIT' bits (*note Storage Layout::).

`QImode'
     "Quarter-Integer" mode represents a single byte treated as an
     integer.

`HImode'
     "Half-Integer" mode represents a two-byte integer.

`PSImode'
     "Partial Single Integer" mode represents an integer which occupies
     four bytes but which doesn't really use all four.  On some
     machines, this is the right mode to use for pointers.

`SImode'
     "Single Integer" mode represents a four-byte integer.

`PDImode'
     "Partial Double Integer" mode represents an integer which occupies
     eight bytes but which doesn't really use all eight.  On some
     machines, this is the right mode to use for certain pointers.

`DImode'
     "Double Integer" mode represents an eight-byte integer.

`TImode'
     "Tetra Integer" (?) mode represents a sixteen-byte integer.

`SFmode'
     "Single Floating" mode represents a single-precision (four byte)
     floating point number.

`DFmode'
     "Double Floating" mode represents a double-precision (eight byte)
     floating point number.

`XFmode'
     "Extended Floating" mode represents a triple-precision (twelve
     byte) floating point number.  This mode is used for IEEE extended
     floating point.  On some systems not all bits within these bytes
     will actually be used.

`TFmode'
     "Tetra Floating" mode represents a quadruple-precision (sixteen
     byte) floating point number.

`CCmode'
     "Condition Code" mode represents the value of a condition code,
     which is a machine-specific set of bits used to represent the
     result of a comparison operation.  Other machine-specific modes
     may also be used for the condition code.  These modes are not used
     on machines that use `cc0' (see *note Condition Code::).

`BLKmode'
     "Block" mode represents values that are aggregates to which none of
     the other modes apply.  In RTL, only memory references can have
     this mode, and only if they appear in string-move or vector
     instructions.  On machines which have no such instructions,
     `BLKmode' will not appear in RTL.

`VOIDmode'
     Void mode means the absence of a mode or an unspecified mode.  For
     example, RTL expressions of code `const_int' have mode `VOIDmode'
     because they can be taken to have whatever mode the context
     requires.  In debugging dumps of RTL, `VOIDmode' is expressed by
     the absence of any mode.

`SCmode, DCmode, XCmode, TCmode'
     These modes stand for a complex number represented as a pair of
     floating point values.  The floating point values are in `SFmode',
     `DFmode', `XFmode', and `TFmode', respectively.

`CQImode, CHImode, CSImode, CDImode, CTImode, COImode'
     These modes stand for a complex number represented as a pair of
     integer values.  The integer values are in `QImode', `HImode',
     `SImode', `DImode', `TImode', and `OImode', respectively.

   The machine description defines `Pmode' as a C macro which expands
into the machine mode used for addresses.  Normally this is the mode
whose size is `BITS_PER_WORD', `SImode' on 32-bit machines.

   The only modes which a machine description must support are
`QImode', and the modes corresponding to `BITS_PER_WORD',
`FLOAT_TYPE_SIZE' and `DOUBLE_TYPE_SIZE'.  The compiler will attempt to
use `DImode' for 8-byte structures and unions, but this can be
prevented by overriding the definition of `MAX_FIXED_MODE_SIZE'.
Alternatively, you can have the compiler use `TImode' for 16-byte
structures and unions.  Likewise, you can arrange for the C type `short
int' to avoid using `HImode'.

   Very few explicit references to machine modes remain in the compiler
and these few references will soon be removed.  Instead, the machine
modes are divided into mode classes.  These are represented by the
enumeration type `enum mode_class' defined in `machmode.h'.  The
possible mode classes are:

`MODE_INT'
     Integer modes.  By default these are `QImode', `HImode', `SImode',
     `DImode', and `TImode'.

`MODE_PARTIAL_INT'
     The "partial integer" modes, `PSImode' and `PDImode'.

`MODE_FLOAT'
     floating point modes.  By default these are `SFmode', `DFmode',
     `XFmode' and `TFmode'.

`MODE_COMPLEX_INT'
     Complex integer modes.  (These are not currently implemented).

`MODE_COMPLEX_FLOAT'
     Complex floating point modes.  By default these are `SCmode',
     `DCmode', `XCmode', and `TCmode'.

`MODE_FUNCTION'
     Algol or Pascal function variables including a static chain.
     (These are not currently implemented).

`MODE_CC'
     Modes representing condition code values.  These are `CCmode' plus
     any modes listed in the `EXTRA_CC_MODES' macro.  *Note Jump
     Patterns::, also see *note Condition Code::.

`MODE_RANDOM'
     This is a catchall mode class for modes which don't fit into the
     above classes.  Currently `VOIDmode' and `BLKmode' are in
     `MODE_RANDOM'.

   Here are some C macros that relate to machine modes:

`GET_MODE (X)'
     Returns the machine mode of the RTX X.

`PUT_MODE (X, NEWMODE)'
     Alters the machine mode of the RTX X to be NEWMODE.

`NUM_MACHINE_MODES'
     Stands for the number of machine modes available on the target
     machine.  This is one greater than the largest numeric value of any
     machine mode.

`GET_MODE_NAME (M)'
     Returns the name of mode M as a string.

`GET_MODE_CLASS (M)'
     Returns the mode class of mode M.

`GET_MODE_WIDER_MODE (M)'
     Returns the next wider natural mode.  For example, the expression
     `GET_MODE_WIDER_MODE (QImode)' returns `HImode'.

`GET_MODE_SIZE (M)'
     Returns the size in bytes of a datum of mode M.

`GET_MODE_BITSIZE (M)'
     Returns the size in bits of a datum of mode M.

`GET_MODE_MASK (M)'
     Returns a bitmask containing 1 for all bits in a word that fit
     within mode M.  This macro can only be used for modes whose
     bitsize is less than or equal to `HOST_BITS_PER_INT'.

`GET_MODE_ALIGNMENT (M))'
     Return the required alignment, in bits, for an object of mode M.

`GET_MODE_UNIT_SIZE (M)'
     Returns the size in bytes of the subunits of a datum of mode M.
     This is the same as `GET_MODE_SIZE' except in the case of complex
     modes.  For them, the unit size is the size of the real or
     imaginary part.

`GET_MODE_NUNITS (M)'
     Returns the number of units contained in a mode, i.e.,
     `GET_MODE_SIZE' divided by `GET_MODE_UNIT_SIZE'.

`GET_CLASS_NARROWEST_MODE (C)'
     Returns the narrowest mode in mode class C.

   The global variables `byte_mode' and `word_mode' contain modes whose
classes are `MODE_INT' and whose bitsizes are either `BITS_PER_UNIT' or
`BITS_PER_WORD', respectively.  On 32-bit machines, these are `QImode'
and `SImode', respectively.


File: gcc.info,  Node: Constants,  Next: Regs and Memory,  Prev: Machine Modes,  Up: RTL

15.6 Constant Expression Types
==============================

The simplest RTL expressions are those that represent constant values.

`(const_int I)'
     This type of expression represents the integer value I.  I is
     customarily accessed with the macro `INTVAL' as in `INTVAL (EXP)',
     which is equivalent to `XWINT (EXP, 0)'.

     There is only one expression object for the integer value zero; it
     is the value of the variable `const0_rtx'.  Likewise, the only
     expression for integer value one is found in `const1_rtx', the only
     expression for integer value two is found in `const2_rtx', and the
     only expression for integer value negative one is found in
     `constm1_rtx'.  Any attempt to create an expression of code
     `const_int' and value zero, one, two or negative one will return
     `const0_rtx', `const1_rtx', `const2_rtx' or `constm1_rtx' as
     appropriate.

     Similarly, there is only one object for the integer whose value is
     `STORE_FLAG_VALUE'.  It is found in `const_true_rtx'.  If
     `STORE_FLAG_VALUE' is one, `const_true_rtx' and `const1_rtx' will
     point to the same object.  If `STORE_FLAG_VALUE' is -1,
     `const_true_rtx' and `constm1_rtx' will point to the same object.

`(const_double:M ADDR I0 I1 ...)'
     Represents either a floating-point constant of mode M or an
     integer constant too large to fit into `HOST_BITS_PER_WIDE_INT'
     bits but small enough to fit within twice that number of bits (GNU
     CC does not provide a mechanism to represent even larger
     constants).  In the latter case, M will be `VOIDmode'.

     ADDR is used to contain the `mem' expression that corresponds to
     the location in memory that at which the constant can be found.  If
     it has not been allocated a memory location, but is on the chain
     of all `const_double' expressions in this compilation (maintained
     using an undisplayed field), ADDR contains `const0_rtx'.  If it is
     not on the chain, ADDR contains `cc0_rtx'.  ADDR is customarily
     accessed with the macro `CONST_DOUBLE_MEM' and the chain field via
     `CONST_DOUBLE_CHAIN'.

     If M is `VOIDmode', the bits of the value are stored in I0 and I1.
     I0 is customarily accessed with the macro `CONST_DOUBLE_LOW' and
     I1 with `CONST_DOUBLE_HIGH'.

     If the constant is floating point (regardless of its precision),
     then the number of integers used to store the value depends on the
     size of `REAL_VALUE_TYPE' (*note Cross-compilation::).  The
     integers represent a floating point number, but not precisely in
     the target machine's or host machine's floating point format.  To
     convert them to the precise bit pattern used by the target
     machine, use the macro `REAL_VALUE_TO_TARGET_DOUBLE' and friends
     (*note Data Output::).

     The macro `CONST0_RTX (MODE)' refers to an expression with value 0
     in mode MODE.  If mode MODE is of mode class `MODE_INT', it
     returns `const0_rtx'.  Otherwise, it returns a `CONST_DOUBLE'
     expression in mode MODE.  Similarly, the macro `CONST1_RTX (MODE)'
     refers to an expression with value 1 in mode MODE and similarly
     for `CONST2_RTX'.

`(const_string STR)'
     Represents a constant string with value STR.  Currently this is
     used only for insn attributes (*note Insn Attributes::) since
     constant strings in C are placed in memory.

`(symbol_ref:MODE SYMBOL)'
     Represents the value of an assembler label for data.  SYMBOL is a
     string that describes the name of the assembler label.  If it
     starts with a `*', the label is the rest of SYMBOL not including
     the `*'.  Otherwise, the label is SYMBOL, usually prefixed with
     `_'.

     The `symbol_ref' contains a mode, which is usually `Pmode'.
     Usually that is the only mode for which a symbol is directly valid.

`(label_ref LABEL)'
     Represents the value of an assembler label for code.  It contains
     one operand, an expression, which must be a `code_label' that
     appears in the instruction sequence to identify the place where
     the label should go.

     The reason for using a distinct expression type for code label
     references is so that jump optimization can distinguish them.

`(const:M EXP)'
     Represents a constant that is the result of an assembly-time
     arithmetic computation.  The operand, EXP, is an expression that
     contains only constants (`const_int', `symbol_ref' and `label_ref'
     expressions) combined with `plus' and `minus'.  However, not all
     combinations are valid, since the assembler cannot do arbitrary
     arithmetic on relocatable symbols.

     M should be `Pmode'.

`(high:M EXP)'
     Represents the high-order bits of EXP, usually a `symbol_ref'.
     The number of bits is machine-dependent and is normally the number
     of bits specified in an instruction that initializes the high
     order bits of a register.  It is used with `lo_sum' to represent
     the typical two-instruction sequence used in RISC machines to
     reference a global memory location.

     M should be `Pmode'.


File: gcc.info,  Node: Regs and Memory,  Next: Arithmetic,  Prev: Constants,  Up: RTL

15.7 Registers and Memory
=========================

Here are the RTL expression types for describing access to machine
registers and to main memory.

`(reg:M N)'
     For small values of the integer N (those that are less than
     `FIRST_PSEUDO_REGISTER'), this stands for a reference to machine
     register number N: a "hard register".  For larger values of N, it
     stands for a temporary value or "pseudo register".  The compiler's
     strategy is to generate code assuming an unlimited number of such
     pseudo registers, and later convert them into hard registers or
     into memory references.

     M is the machine mode of the reference.  It is necessary because
     machines can generally refer to each register in more than one
     mode.  For example, a register may contain a full word but there
     may be instructions to refer to it as a half word or as a single
     byte, as well as instructions to refer to it as a floating point
     number of various precisions.

     Even for a register that the machine can access in only one mode,
     the mode must always be specified.

     The symbol `FIRST_PSEUDO_REGISTER' is defined by the machine
     description, since the number of hard registers on the machine is
     an invariant characteristic of the machine.  Note, however, that
     not all of the machine registers must be general registers.  All
     the machine registers that can be used for storage of data are
     given hard register numbers, even those that can be used only in
     certain instructions or can hold only certain types of data.

     A hard register may be accessed in various modes throughout one
     function, but each pseudo register is given a natural mode and is
     accessed only in that mode.  When it is necessary to describe an
     access to a pseudo register using a nonnatural mode, a `subreg'
     expression is used.

     A `reg' expression with a machine mode that specifies more than
     one word of data may actually stand for several consecutive
     registers.  If in addition the register number specifies a
     hardware register, then it actually represents several consecutive
     hardware registers starting with the specified one.

     Each pseudo register number used in a function's RTL code is
     represented by a unique `reg' expression.

     Some pseudo register numbers, those within the range of
     `FIRST_VIRTUAL_REGISTER' to `LAST_VIRTUAL_REGISTER' only appear
     during the RTL generation phase and are eliminated before the
     optimization phases.  These represent locations in the stack frame
     that cannot be determined until RTL generation for the function
     has been completed.  The following virtual register numbers are
     defined:

    `VIRTUAL_INCOMING_ARGS_REGNUM'
          This points to the first word of the incoming arguments
          passed on the stack.  Normally these arguments are placed
          there by the caller, but the callee may have pushed some
          arguments that were previously passed in registers.

          When RTL generation is complete, this virtual register is
          replaced by the sum of the register given by
          `ARG_POINTER_REGNUM' and the value of `FIRST_PARM_OFFSET'.

    `VIRTUAL_STACK_VARS_REGNUM'
          If `FRAME_GROWS_DOWNWARD' is defined, this points to
          immediately above the first variable on the stack.
          Otherwise, it points to the first variable on the stack.

          `VIRTUAL_STACK_VARS_REGNUM' is replaced with the sum of the
          register given by `FRAME_POINTER_REGNUM' and the value
          `STARTING_FRAME_OFFSET'.

    `VIRTUAL_STACK_DYNAMIC_REGNUM'
          This points to the location of dynamically allocated memory
          on the stack immediately after the stack pointer has been
          adjusted by the amount of memory desired.

          This virtual register is replaced by the sum of the register
          given by `STACK_POINTER_REGNUM' and the value
          `STACK_DYNAMIC_OFFSET'.

    `VIRTUAL_OUTGOING_ARGS_REGNUM'
          This points to the location in the stack at which outgoing
          arguments should be written when the stack is pre-pushed
          (arguments pushed using push insns should always use
          `STACK_POINTER_REGNUM').

          This virtual register is replaced by the sum of the register
          given by `STACK_POINTER_REGNUM' and the value
          `STACK_POINTER_OFFSET'.

`(subreg:M REG WORDNUM)'
     `subreg' expressions are used to refer to a register in a machine
     mode other than its natural one, or to refer to one register of a
     multi-word `reg' that actually refers to several registers.

     Each pseudo-register has a natural mode.  If it is necessary to
     operate on it in a different mode--for example, to perform a
     fullword move instruction on a pseudo-register that contains a
     single byte--the pseudo-register must be enclosed in a `subreg'.
     In such a case, WORDNUM is zero.

     Usually M is at least as narrow as the mode of REG, in which case
     it is restricting consideration to only the bits of REG that are
     in M.

     Sometimes M is wider than the mode of REG.  These `subreg'
     expressions are often called "paradoxical".  They are used in
     cases where we want to refer to an object in a wider mode but do
     not care what value the additional bits have.  The reload pass
     ensures that paradoxical references are only made to hard
     registers.

     The other use of `subreg' is to extract the individual registers of
     a multi-register value.  Machine modes such as `DImode' and
     `TImode' can indicate values longer than a word, values which
     usually require two or more consecutive registers.  To access one
     of the registers, use a `subreg' with mode `SImode' and a WORDNUM
     that says which register.

     Storing in a non-paradoxical `subreg' has undefined results for
     bits belonging to the same word as the `subreg'.  This laxity makes
     it easier to generate efficient code for such instructions.  To
     represent an instruction that preserves all the bits outside of
     those in the `subreg', use `strict_low_part' around the `subreg'.

     The compilation parameter `WORDS_BIG_ENDIAN', if set to 1, says
     that word number zero is the most significant part; otherwise, it
     is the least significant part.

     On a few targets, `FLOAT_WORDS_BIG_ENDIAN' disagrees with
     `WORDS_BIG_ENDIAN'.  However, most parts of the compiler treat
     floating point values as if they had the same endianness as
     integer values.  This works because they handle them solely as a
     collection of integer values, with no particular numerical value.
     Only real.c and the runtime libraries care about
     `FLOAT_WORDS_BIG_ENDIAN'.

     Between the combiner pass and the reload pass, it is possible to
     have a paradoxical `subreg' which contains a `mem' instead of a
     `reg' as its first operand.  After the reload pass, it is also
     possible to have a non-paradoxical `subreg' which contains a
     `mem'; this usually occurs when the `mem' is a stack slot which
     replaced a pseudo register.

     Note that it is not valid to access a `DFmode' value in `SFmode'
     using a `subreg'.  On some machines the most significant part of a
     `DFmode' value does not have the same format as a single-precision
     floating value.

     It is also not valid to access a single word of a multi-word value
     in a hard register when less registers can hold the value than
     would be expected from its size.  For example, some 32-bit
     machines have floating-point registers that can hold an entire
     `DFmode' value.  If register 10 were such a register `(subreg:SI
     (reg:DF 10) 1)' would be invalid because there is no way to
     convert that reference to a single machine register.  The reload
     pass prevents `subreg' expressions such as these from being formed.

     The first operand of a `subreg' expression is customarily accessed
     with the `SUBREG_REG' macro and the second operand is customarily
     accessed with the `SUBREG_WORD' macro.

`(scratch:M)'
     This represents a scratch register that will be required for the
     execution of a single instruction and not used subsequently.  It is
     converted into a `reg' by either the local register allocator or
     the reload pass.

     `scratch' is usually present inside a `clobber' operation (*note
     Side Effects::).

`(cc0)'
     This refers to the machine's condition code register.  It has no
     operands and may not have a machine mode.  There are two ways to
     use it:

        * To stand for a complete set of condition code flags.  This is
          best on most machines, where each comparison sets the entire
          series of flags.

          With this technique, `(cc0)' may be validly used in only two
          contexts: as the destination of an assignment (in test and
          compare instructions) and in comparison operators comparing
          against zero (`const_int' with value zero; that is to say,
          `const0_rtx').

        * To stand for a single flag that is the result of a single
          condition.  This is useful on machines that have only a
          single flag bit, and in which comparison instructions must
          specify the condition to test.

          With this technique, `(cc0)' may be validly used in only two
          contexts: as the destination of an assignment (in test and
          compare instructions) where the source is a comparison
          operator, and as the first operand of `if_then_else' (in a
          conditional branch).

     There is only one expression object of code `cc0'; it is the value
     of the variable `cc0_rtx'.  Any attempt to create an expression of
     code `cc0' will return `cc0_rtx'.

     Instructions can set the condition code implicitly.  On many
     machines, nearly all instructions set the condition code based on
     the value that they compute or store.  It is not necessary to
     record these actions explicitly in the RTL because the machine
     description includes a prescription for recognizing the
     instructions that do so (by means of the macro
     `NOTICE_UPDATE_CC').  *Note Condition Code::.  Only instructions
     whose sole purpose is to set the condition code, and instructions
     that use the condition code, need mention `(cc0)'.

     On some machines, the condition code register is given a register
     number and a `reg' is used instead of `(cc0)'.  This is usually the
     preferable approach if only a small subset of instructions modify
     the condition code.  Other machines store condition codes in
     general registers; in such cases a pseudo register should be used.

     Some machines, such as the Sparc and RS/6000, have two sets of
     arithmetic instructions, one that sets and one that does not set
     the condition code.  This is best handled by normally generating
     the instruction that does not set the condition code, and making a
     pattern that both performs the arithmetic and sets the condition
     code register (which would not be `(cc0)' in this case).  For
     examples, search for `addcc' and `andcc' in `sparc.md'.

`(pc)'
     This represents the machine's program counter.  It has no operands
     and may not have a machine mode.  `(pc)' may be validly used only
     in certain specific contexts in jump instructions.

     There is only one expression object of code `pc'; it is the value
     of the variable `pc_rtx'.  Any attempt to create an expression of
     code `pc' will return `pc_rtx'.

     All instructions that do not jump alter the program counter
     implicitly by incrementing it, but there is no need to mention
     this in the RTL.

`(mem:M ADDR)'
     This RTX represents a reference to main memory at an address
     represented by the expression ADDR.  M specifies how large a unit
     of memory is accessed.

`(addressof:M REG)'
     This RTX represents a request for the address of register REG.
     Its mode is always `Pmode'.  If there are any `addressof'
     expressions left in the function after CSE, REG is forced into the
     stack and the `addressof' expression is replaced with a `plus'
     expression for the address of its stack slot.


File: gcc.info,  Node: Arithmetic,  Next: Comparisons,  Prev: Regs and Memory,  Up: RTL

15.8 RTL Expressions for Arithmetic
===================================

Unless otherwise specified, all the operands of arithmetic expressions
must be valid for mode M.  An operand is valid for mode M if it has
mode M, or if it is a `const_int' or `const_double' and M is a mode of
class `MODE_INT'.

   For commutative binary operations, constants should be placed in the
second operand.

`(plus:M X Y)'
     Represents the sum of the values represented by X and Y carried
     out in machine mode M.

`(lo_sum:M X Y)'
     Like `plus', except that it represents that sum of X and the
     low-order bits of Y.  The number of low order bits is
     machine-dependent but is normally the number of bits in a `Pmode'
     item minus the number of bits set by the `high' code (*note
     Constants::).

     M should be `Pmode'.

`(minus:M X Y)'
     Like `plus' but represents subtraction.

`(compare:M X Y)'
     Represents the result of subtracting Y from X for purposes of
     comparison.  The result is computed without overflow, as if with
     infinite precision.

     Of course, machines can't really subtract with infinite precision.
     However, they can pretend to do so when only the sign of the
     result will be used, which is the case when the result is stored
     in the condition code.   And that is the only way this kind of
     expression may validly be used: as a value to be stored in the
     condition codes.

     The mode M is not related to the modes of X and Y, but instead is
     the mode of the condition code value.  If `(cc0)' is used, it is
     `VOIDmode'.  Otherwise it is some mode in class `MODE_CC', often
     `CCmode'.  *Note Condition Code::.

     Normally, X and Y must have the same mode.  Otherwise, `compare'
     is valid only if the mode of X is in class `MODE_INT' and Y is a
     `const_int' or `const_double' with mode `VOIDmode'.  The mode of X
     determines what mode the comparison is to be done in; thus it must
     not be `VOIDmode'.

     If one of the operands is a constant, it should be placed in the
     second operand and the comparison code adjusted as appropriate.

     A `compare' specifying two `VOIDmode' constants is not valid since
     there is no way to know in what mode the comparison is to be
     performed; the comparison must either be folded during the
     compilation or the first operand must be loaded into a register
     while its mode is still known.

`(neg:M X)'
     Represents the negation (subtraction from zero) of the value
     represented by X, carried out in mode M.

`(mult:M X Y)'
     Represents the signed product of the values represented by X and Y
     carried out in machine mode M.

     Some machines support a multiplication that generates a product
     wider than the operands.  Write the pattern for this as

          (mult:M (sign_extend:M X) (sign_extend:M Y))

     where M is wider than the modes of X and Y, which need not be the
     same.

     Write patterns for unsigned widening multiplication similarly using
     `zero_extend'.

`(div:M X Y)'
     Represents the quotient in signed division of X by Y, carried out
     in machine mode M.  If M is a floating point mode, it represents
     the exact quotient; otherwise, the integerized quotient.

     Some machines have division instructions in which the operands and
     quotient widths are not all the same; you should represent such
     instructions using `truncate' and `sign_extend' as in,

          (truncate:M1 (div:M2 X (sign_extend:M2 Y)))

`(udiv:M X Y)'
     Like `div' but represents unsigned division.

`(mod:M X Y)'
`(umod:M X Y)'
     Like `div' and `udiv' but represent the remainder instead of the
     quotient.

`(smin:M X Y)'
`(smax:M X Y)'
     Represents the smaller (for `smin') or larger (for `smax') of X
     and Y, interpreted as signed integers in mode M.

`(umin:M X Y)'
`(umax:M X Y)'
     Like `smin' and `smax', but the values are interpreted as unsigned
     integers.

`(not:M X)'
     Represents the bitwise complement of the value represented by X,
     carried out in mode M, which must be a fixed-point machine mode.

`(and:M X Y)'
     Represents the bitwise logical-and of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     machine mode.

`(ior:M X Y)'
     Represents the bitwise inclusive-or of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     mode.

`(xor:M X Y)'
     Represents the bitwise exclusive-or of the values represented by X
     and Y, carried out in machine mode M, which must be a fixed-point
     mode.

`(ashift:M X C)'
     Represents the result of arithmetically shifting X left by C
     places.  X have mode M, a fixed-point machine mode.  C be a
     fixed-point mode or be a constant with mode `VOIDmode'; which mode
     is determined by the mode called for in the machine description
     entry for the left-shift instruction.  For example, on the Vax,
     the mode of C is `QImode' regardless of M.

`(lshiftrt:M X C)'
`(ashiftrt:M X C)'
     Like `ashift' but for right shift.  Unlike the case for left shift,
     these two operations are distinct.

`(rotate:M X C)'
`(rotatert:M X C)'
     Similar but represent left and right rotate.  If C is a constant,
     use `rotate'.

`(abs:M X)'
     Represents the absolute value of X, computed in mode M.

`(sqrt:M X)'
     Represents the square root of X, computed in mode M.  Most often M
     will be a floating point mode.

`(ffs:M X)'
     Represents one plus the index of the least significant 1-bit in X,
     represented as an integer of mode M.  (The value is zero if X is
     zero.)  The mode of X need not be M; depending on the target
     machine, various mode combinations may be valid.


File: gcc.info,  Node: Comparisons,  Next: Bit Fields,  Prev: Arithmetic,  Up: RTL

15.9 Comparison Operations
==========================

Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, `STORE_FLAG_VALUE' (*note Misc::) if the relation
holds, or zero if it does not.  The mode of the comparison operation is
independent of the mode of the data being compared.  If the comparison
operation is being tested (e.g., the first operand of an
`if_then_else'), the mode must be `VOIDmode'.  If the comparison
operation is producing data to be stored in some variable, the mode
must be in class `MODE_INT'.  All comparison operations producing data
must use the same mode, which is machine-specific.

   There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes `(cc0)'
against zero, as in `(eq (cc0) (const_int 0))'.  Such a construct
actually refers to the result of the preceding instruction in which the
condition codes were set.  The instructing setting the condition code
must be adjacent to the instruction using the condition code; only
`note' insns may separate them.

   Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

   In the example above, if `(cc0)' were last set to `(compare X Y)',
the comparison operation is identical to `(eq X Y)'.  Usually only one
style of comparisons is supported on a particular machine, but the
combine pass will try to merge the operations to produce the `eq' shown
in case it exists in the context of the particular insn involved.

   Inequality comparisons come in two flavors, signed and unsigned.
Thus, there are distinct expression codes `gt' and `gtu' for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than -1 but not
unsigned greater-than, because -1 when regarded as unsigned is actually
`0xffffffff' which is greater than 1.

   The signed comparisons are also used for floating point values.
Floating point comparisons are distinguished by the machine modes of
the operands.

`(eq:M X Y)'
     1 if the values represented by X and Y are equal, otherwise 0.

`(ne:M X Y)'
     1 if the values represented by X and Y are not equal, otherwise 0.

`(gt:M X Y)'
     1 if the X is greater than Y.  If they are fixed-point, the
     comparison is done in a signed sense.

`(gtu:M X Y)'
     Like `gt' but does unsigned comparison, on fixed-point numbers
     only.

`(lt:M X Y)'
`(ltu:M X Y)'
     Like `gt' and `gtu' but test for "less than".

`(ge:M X Y)'
`(geu:M X Y)'
     Like `gt' and `gtu' but test for "greater than or equal".

`(le:M X Y)'
`(leu:M X Y)'
     Like `gt' and `gtu' but test for "less than or equal".

`(if_then_else COND THEN ELSE)'
     This is not a comparison operation but is listed here because it is
     always used in conjunction with a comparison operation.  To be
     precise, COND is a comparison expression.  This expression
     represents a choice, according to COND, between the value
     represented by THEN and the one represented by ELSE.

     On most machines, `if_then_else' expressions are valid only to
     express conditional jumps.

`(cond [TEST1 VALUE1 TEST2 VALUE2 ...] DEFAULT)'
     Similar to `if_then_else', but more general.  Each of TEST1,
     TEST2, ... is performed in turn.  The result of this expression is
     the VALUE corresponding to the first non-zero test, or DEFAULT if
     none of the tests are non-zero expressions.

     This is currently not valid for instruction patterns and is
     supported only for insn attributes.  *Note Insn Attributes::.


File: gcc.info,  Node: Bit Fields,  Next: Conversions,  Prev: Comparisons,  Up: RTL

15.10 Bit Fields
================

Special expression codes exist to represent bitfield instructions.
These types of expressions are lvalues in RTL; they may appear on the
left side of an assignment, indicating insertion of a value into the
specified bit field.

`(sign_extract:M LOC SIZE POS)'
     This represents a reference to a sign-extended bit field contained
     or starting in LOC (a memory or register reference).  The bit field
     is SIZE bits wide and starts at bit POS.  The compilation option
     `BITS_BIG_ENDIAN' says which end of the memory unit POS counts
     from.

     If LOC is in memory, its mode must be a single-byte integer mode.
     If LOC is in a register, the mode to use is specified by the
     operand of the `insv' or `extv' pattern (*note Standard Names::)
     and is usually a full-word integer mode, which is the default if
     none is specified.

     The mode of POS is machine-specific and is also specified in the
     `insv' or `extv' pattern.

     The mode M is the same as the mode that would be used for LOC if
     it were a register.

`(zero_extract:M LOC SIZE POS)'
     Like `sign_extract' but refers to an unsigned or zero-extended bit
     field.  The same sequence of bits are extracted, but they are
     filled to an entire word with zeros instead of by sign-extension.


File: gcc.info,  Node: Conversions,  Next: RTL Declarations,  Prev: Bit Fields,  Up: RTL

15.11 Conversions
=================

All conversions between machine modes must be represented by explicit
conversion operations.  For example, an expression which is the sum of
a byte and a full word cannot be written as `(plus:SI (reg:QI 34)
(reg:SI 80))' because the `plus' operation requires two operands of the
same machine mode.  Therefore, the byte-sized operand is enclosed in a
conversion operation, as in

     (plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))

   The conversion operation is not a mere placeholder, because there
may be more than one way of converting from a given starting mode to
the desired final mode.  The conversion operation code says how to do
it.

   For all conversion operations, X must not be `VOIDmode' because the
mode in which to do the conversion would not be known.  The conversion
must either be done at compile-time or X must be placed into a register.

`(sign_extend:M X)'
     Represents the result of sign-extending the value X to machine
     mode M.  M must be a fixed-point mode and X a fixed-point value of
     a mode narrower than M.

`(zero_extend:M X)'
     Represents the result of zero-extending the value X to machine
     mode M.  M must be a fixed-point mode and X a fixed-point value of
     a mode narrower than M.

`(float_extend:M X)'
     Represents the result of extending the value X to machine mode M.
     M must be a floating point mode and X a floating point value of a
     mode narrower than M.

`(truncate:M X)'
     Represents the result of truncating the value X to machine mode M.
     M must be a fixed-point mode and X a fixed-point value of a mode
     wider than M.

`(float_truncate:M X)'
     Represents the result of truncating the value X to machine mode M.
     M must be a floating point mode and X a floating point value of a
     mode wider than M.

`(float:M X)'
     Represents the result of converting fixed point value X, regarded
     as signed, to floating point mode M.

`(unsigned_float:M X)'
     Represents the result of converting fixed point value X, regarded
     as unsigned, to floating point mode M.

`(fix:M X)'
     When M is a fixed point mode, represents the result of converting
     floating point value X to mode M, regarded as signed.  How
     rounding is done is not specified, so this operation may be used
     validly in compiling C code only for integer-valued operands.

`(unsigned_fix:M X)'
     Represents the result of converting floating point value X to
     fixed point mode M, regarded as unsigned.  How rounding is done is
     not specified.

`(fix:M X)'
     When M is a floating point mode, represents the result of
     converting floating point value X (valid for mode M) to an
     integer, still represented in floating point mode M, by rounding
     towards zero.


File: gcc.info,  Node: RTL Declarations,  Next: Side Effects,  Prev: Conversions,  Up: RTL

15.12 Declarations
==================

Declaration expression codes do not represent arithmetic operations but
rather state assertions about their operands.

`(strict_low_part (subreg:M (reg:N R) 0))'
     This expression code is used in only one context: as the
     destination operand of a `set' expression.  In addition, the
     operand of this expression must be a non-paradoxical `subreg'
     expression.

     The presence of `strict_low_part' says that the part of the
     register which is meaningful in mode N, but is not part of mode M,
     is not to be altered.  Normally, an assignment to such a subreg is
     allowed to have undefined effects on the rest of the register when
     M is less than a word.


File: gcc.info,  Node: Side Effects,  Next: Incdec,  Prev: RTL Declarations,  Up: RTL

15.13 Side Effect Expressions
=============================

The expression codes described so far represent values, not actions.
But machine instructions never produce values; they are meaningful only
for their side effects on the state of the machine.  Special expression
codes are used to represent side effects.

   The body of an instruction is always one of these side effect codes;
the codes described above, which represent values, appear only as the
operands of these.

`(set LVAL X)'
     Represents the action of storing the value of X into the place
     represented by LVAL.  LVAL must be an expression representing a
     place that can be stored in: `reg' (or `subreg' or
     `strict_low_part'), `mem', `pc' or `cc0'.

     If LVAL is a `reg', `subreg' or `mem', it has a machine mode; then
     X must be valid for that mode.

     If LVAL is a `reg' whose machine mode is less than the full width
     of the register, then it means that the part of the register
     specified by the machine mode is given the specified value and the
     rest of the register receives an undefined value.  Likewise, if
     LVAL is a `subreg' whose machine mode is narrower than the mode of
     the register, the rest of the register can be changed in an
     undefined way.

     If LVAL is a `strict_low_part' of a `subreg', then the part of the
     register specified by the machine mode of the `subreg' is given
     the value X and the rest of the register is not changed.

     If LVAL is `(cc0)', it has no machine mode, and X may be either a
     `compare' expression or a value that may have any mode.  The
     latter case represents a "test" instruction.  The expression `(set
     (cc0) (reg:M N))' is equivalent to `(set (cc0) (compare (reg:M N)
     (const_int 0)))'.  Use the former expression to save space during
     the compilation.

     If LVAL is `(pc)', we have a jump instruction, and the
     possibilities for X are very limited.  It may be a `label_ref'
     expression (unconditional jump).  It may be an `if_then_else'
     (conditional jump), in which case either the second or the third
     operand must be `(pc)' (for the case which does not jump) and the
     other of the two must be a `label_ref' (for the case which does
     jump).  X may also be a `mem' or `(plus:SI (pc) Y)', where Y may
     be a `reg' or a `mem'; these unusual patterns are used to
     represent jumps through branch tables.

     If LVAL is neither `(cc0)' nor `(pc)', the mode of LVAL must not
     be `VOIDmode' and the mode of X must be valid for the mode of LVAL.

     LVAL is customarily accessed with the `SET_DEST' macro and X with
     the `SET_SRC' macro.

`(return)'
     As the sole expression in a pattern, represents a return from the
     current function, on machines where this can be done with one
     instruction, such as Vaxes.  On machines where a multi-instruction
     "epilogue" must be executed in order to return from the function,
     returning is done by jumping to a label which precedes the
     epilogue, and the `return' expression code is never used.

     Inside an `if_then_else' expression, represents the value to be
     placed in `pc' to return to the caller.

     Note that an insn pattern of `(return)' is logically equivalent to
     `(set (pc) (return))', but the latter form is never used.

`(call FUNCTION NARGS)'
     Represents a function call.  FUNCTION is a `mem' expression whose
     address is the address of the function to be called.  NARGS is an
     expression which can be used for two purposes: on some machines it
     represents the number of bytes of stack argument; on others, it
     represents the number of argument registers.

     Each machine has a standard machine mode which FUNCTION must have.
     The machine description defines macro `FUNCTION_MODE' to expand
     into the requisite mode name.  The purpose of this mode is to
     specify what kind of addressing is allowed, on machines where the
     allowed kinds of addressing depend on the machine mode being
     addressed.

`(clobber X)'
     Represents the storing or possible storing of an unpredictable,
     undescribed value into X, which must be a `reg', `scratch' or
     `mem' expression.

     One place this is used is in string instructions that store
     standard values into particular hard registers.  It may not be
     worth the trouble to describe the values that are stored, but it
     is essential to inform the compiler that the registers will be
     altered, lest it attempt to keep data in them across the string
     instruction.

     If X is `(mem:BLK (const_int 0))', it means that all memory
     locations must be presumed clobbered.

     Note that the machine description classifies certain hard
     registers as "call-clobbered".  All function call instructions are
     assumed by default to clobber these registers, so there is no need
     to use `clobber' expressions to indicate this fact.  Also, each
     function call is assumed to have the potential to alter any memory
     location, unless the function is declared `const'.

     If the last group of expressions in a `parallel' are each a
     `clobber' expression whose arguments are `reg' or `match_scratch'
     (*note RTL Template::) expressions, the combiner phase can add the
     appropriate `clobber' expressions to an insn it has constructed
     when doing so will cause a pattern to be matched.

     This feature can be used, for example, on a machine that whose
     multiply and add instructions don't use an MQ register but which
     has an add-accumulate instruction that does clobber the MQ
     register.  Similarly, a combined instruction might require a
     temporary register while the constituent instructions might not.

     When a `clobber' expression for a register appears inside a
     `parallel' with other side effects, the register allocator
     guarantees that the register is unoccupied both before and after
     that insn.  However, the reload phase may allocate a register used
     for one of the inputs unless the `&' constraint is specified for
     the selected alternative (*note Modifiers::).  You can clobber
     either a specific hard register, a pseudo register, or a `scratch'
     expression; in the latter two cases, GNU CC will allocate a hard
     register that is available there for use as a temporary.

     For instructions that require a temporary register, you should use
     `scratch' instead of a pseudo-register because this will allow the
     combiner phase to add the `clobber' when required.  You do this by
     coding (`clobber' (`match_scratch' ...)).  If you do clobber a
     pseudo register, use one which appears nowhere else--generate a
     new one each time.  Otherwise, you may confuse CSE.

     There is one other known use for clobbering a pseudo register in a
     `parallel': when one of the input operands of the insn is also
     clobbered by the insn.  In this case, using the same pseudo
     register in the clobber and elsewhere in the insn produces the
     expected results.

`(use X)'
     Represents the use of the value of X.  It indicates that the value
     in X at this point in the program is needed, even though it may
     not be apparent why this is so.  Therefore, the compiler will not
     attempt to delete previous instructions whose only effect is to
     store a value in X.  X must be a `reg' expression.

     During the reload phase, an insn that has a `use' as pattern can
     carry a reg_equal note.  These `use' insns will be deleted before
     the reload phase exits.

     During the delayed branch scheduling phase, X may be an insn.
     This indicates that X previously was located at this place in the
     code and its data dependencies need to be taken into account.
     These `use' insns will be deleted before the delayed branch
     scheduling phase exits.

`(parallel [X0 X1 ...])'
     Represents several side effects performed in parallel.  The square
     brackets stand for a vector; the operand of `parallel' is a vector
     of expressions.  X0, X1 and so on are individual side effect
     expressions--expressions of code `set', `call', `return',
     `clobber' or `use'.

     "In parallel" means that first all the values used in the
     individual side-effects are computed, and second all the actual
     side-effects are performed.  For example,

          (parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
                     (set (mem:SI (reg:SI 1)) (reg:SI 1))])

     says unambiguously that the values of hard register 1 and the
     memory location addressed by it are interchanged.  In both places
     where `(reg:SI 1)' appears as a memory address it refers to the
     value in register 1 _before_ the execution of the insn.

     It follows that it is _incorrect_ to use `parallel' and expect the
     result of one `set' to be available for the next one.  For
     example, people sometimes attempt to represent a jump-if-zero
     instruction this way:

          (parallel [(set (cc0) (reg:SI 34))
                     (set (pc) (if_then_else
                                  (eq (cc0) (const_int 0))
                                  (label_ref ...)
                                  (pc)))])

     But this is incorrect, because it says that the jump condition
     depends on the condition code value _before_ this instruction, not
     on the new value that is set by this instruction.

     Peephole optimization, which takes place together with final
     assembly code output, can produce insns whose patterns consist of
     a `parallel' whose elements are the operands needed to output the
     resulting assembler code--often `reg', `mem' or constant
     expressions.  This would not be well-formed RTL at any other stage
     in compilation, but it is ok then because no further optimization
     remains to be done.  However, the definition of the macro
     `NOTICE_UPDATE_CC', if any, must deal with such insns if you
     define any peephole optimizations.

`(sequence [INSNS ...])'
     Represents a sequence of insns.  Each of the INSNS that appears in
     the vector is suitable for appearing in the chain of insns, so it
     must be an `insn', `jump_insn', `call_insn', `code_label',
     `barrier' or `note'.

     A `sequence' RTX is never placed in an actual insn during RTL
     generation.  It represents the sequence of insns that result from a
     `define_expand' _before_ those insns are passed to `emit_insn' to
     insert them in the chain of insns.  When actually inserted, the
     individual sub-insns are separated out and the `sequence' is
     forgotten.

     After delay-slot scheduling is completed, an insn and all the
     insns that reside in its delay slots are grouped together into a
     `sequence'.  The insn requiring the delay slot is the first insn
     in the vector; subsequent insns are to be placed in the delay slot.

     `INSN_ANNULLED_BRANCH_P' is set on an insn in a delay slot to
     indicate that a branch insn should be used that will conditionally
     annul the effect of the insns in the delay slots.  In such a case,
     `INSN_FROM_TARGET_P' indicates that the insn is from the target of
     the branch and should be executed only if the branch is taken;
     otherwise the insn should be executed only if the branch is not
     taken.  *Note Delay Slots::.

   These expression codes appear in place of a side effect, as the body
of an insn, though strictly speaking they do not always describe side
effects as such:

`(asm_input S)'
     Represents literal assembler code as described by the string S.

`(unspec [OPERANDS ...] INDEX)'
`(unspec_volatile [OPERANDS ...] INDEX)'
     Represents a machine-specific operation on OPERANDS.  INDEX
     selects between multiple machine-specific operations.
     `unspec_volatile' is used for volatile operations and operations
     that may trap; `unspec' is used for other operations.

     These codes may appear inside a `pattern' of an insn, inside a
     `parallel', or inside an expression.

`(addr_vec:M [LR0 LR1 ...])'
     Represents a table of jump addresses.  The vector elements LR0,
     etc., are `label_ref' expressions.  The mode M specifies how much
     space is given to each address; normally M would be `Pmode'.

`(addr_diff_vec:M BASE [LR0 LR1 ...] MIN MAX FLAGS)'
     Represents a table of jump addresses expressed as offsets from
     BASE.  The vector elements LR0, etc., are `label_ref' expressions
     and so is BASE.  The mode M specifies how much space is given to
     each address-difference.  MIN and MAX are set up by branch
     shortening and hold a label with a minimum and a maximum address,
     respectively.  FLAGS indicates the relative position of BASE, MIN
     and MAX to the cointaining insn and of MIN and MAX to BASE.  See
     rtl.def for details.


File: gcc.info,  Node: Incdec,  Next: Assembler,  Prev: Side Effects,  Up: RTL

15.14 Embedded Side-Effects on Addresses
========================================

Six special side-effect expression codes appear as memory addresses.

`(pre_dec:M X)'
     Represents the side effect of decrementing X by a standard amount
     and represents also the value that X has after being decremented.
     X must be a `reg' or `mem', but most machines allow only a `reg'.
     M must be the machine mode for pointers on the machine in use.
     The amount X is decremented by is the length in bytes of the
     machine mode of the containing memory reference of which this
     expression serves as the address.  Here is an example of its use:

          (mem:DF (pre_dec:SI (reg:SI 39)))

     This says to decrement pseudo register 39 by the length of a
     `DFmode' value and use the result to address a `DFmode' value.

`(pre_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

`(post_dec:M X)'
     Represents the same side effect as `pre_dec' but a different
     value.  The value represented here is the value X has before being
     decremented.

`(post_inc:M X)'
     Similar, but specifies incrementing X instead of decrementing it.

`(post_modify:M X Y)'
     Represents the side effect of setting X to Y and represents X
     before X is modified.  X must be a `reg' or `mem', but most
     machines allow only a `reg'.  M must be the machine mode for
     pointers on the machine in use.  The amount X is decremented by is
     the length in bytes of the machine mode of the containing memory
     reference of which this expression serves as the address.  Note
     that this is not currently implemented.

     The expression Y must be one of three forms:
          `(plus:M X Z)', `(minus:M X Z)', or `(plus:M X I)',
     where Z is an index register and I is a constant.

     Here is an example of its use:

          (mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42) (reg:SI 48))))

     This says to modify pseudo register 42 by adding the contents of
     pseudo register 48 to it, after the use of what ever 42 points to.

`(pre_modify:M X EXPR)'
     Similar except side effects happen before the use.

   These embedded side effect expressions must be used with care.
Instruction patterns may not use them.  Until the `flow' pass of the
compiler, they may occur only to represent pushes onto the stack.  The
`flow' pass finds cases where registers are incremented or decremented
in one instruction and used as an address shortly before or after;
these cases are then transformed to use pre- or post-increment or
-decrement.

   If a register used as the operand of these expressions is used in
another address in an insn, the original value of the register is used.
Uses of the register outside of an address are not permitted within the
same insn as a use in an embedded side effect expression because such
insns behave differently on different machines and hence must be treated
as ambiguous and disallowed.

   An instruction that can be represented with an embedded side effect
could also be represented using `parallel' containing an additional
`set' to describe how the address register is altered.  This is not
done because machines that allow these operations at all typically
allow them wherever a memory address is called for.  Describing them as
additional parallel stores would require doubling the number of entries
in the machine description.


File: gcc.info,  Node: Assembler,  Next: Insns,  Prev: Incdec,  Up: RTL

15.15 Assembler Instructions as Expressions
===========================================

The RTX code `asm_operands' represents a value produced by a
user-specified assembler instruction.  It is used to represent an `asm'
statement with arguments.  An `asm' statement with a single output
operand, like this:

     asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));

is represented using a single `asm_operands' RTX which represents the
value that is stored in `outputvar':

     (set RTX-FOR-OUTPUTVAR
          (asm_operands "foo %1,%2,%0" "a" 0
                        [RTX-FOR-ADDITION-RESULT RTX-FOR-*Z]
                        [(asm_input:M1 "g")
                         (asm_input:M2 "di")]))

Here the operands of the `asm_operands' RTX are the assembler template
string, the output-operand's constraint, the index-number of the output
operand among the output operands specified, a vector of input operand
RTX's, and a vector of input-operand modes and constraints.  The mode
M1 is the mode of the sum `x+y'; M2 is that of `*z'.

   When an `asm' statement has multiple output values, its insn has
several such `set' RTX's inside of a `parallel'.  Each `set' contains a
`asm_operands'; all of these share the same assembler template and
vectors, but each contains the constraint for the respective output
operand.  They are also distinguished by the output-operand index
number, which is 0, 1, ... for successive output operands.


File: gcc.info,  Node: Insns,  Next: Calls,  Prev: Assembler,  Up: RTL

15.16 Insns
===========

The RTL representation of the code for a function is a doubly-linked
chain of objects called "insns".  Insns are expressions with special
codes that are used for no other purpose.  Some insns are actual
instructions; others represent dispatch tables for `switch' statements;
others represent labels to jump to or various sorts of declarative
information.

   In addition to its own specific data, each insn must have a unique
id-number that distinguishes it from all other insns in the current
function (after delayed branch scheduling, copies of an insn with the
same id-number may be present in multiple places in a function, but
these copies will always be identical and will only appear inside a
`sequence'), and chain pointers to the preceding and following insns.
These three fields occupy the same position in every insn, independent
of the expression code of the insn.  They could be accessed with `XEXP'
and `XINT', but instead three special macros are always used:

`INSN_UID (I)'
     Accesses the unique id of insn I.

`PREV_INSN (I)'
     Accesses the chain pointer to the insn preceding I.  If I is the
     first insn, this is a null pointer.

`NEXT_INSN (I)'
     Accesses the chain pointer to the insn following I.  If I is the
     last insn, this is a null pointer.

   The first insn in the chain is obtained by calling `get_insns'; the
last insn is the result of calling `get_last_insn'.  Within the chain
delimited by these insns, the `NEXT_INSN' and `PREV_INSN' pointers must
always correspond: if INSN is not the first insn,

     NEXT_INSN (PREV_INSN (INSN)) == INSN

is always true and if INSN is not the last insn,

     PREV_INSN (NEXT_INSN (INSN)) == INSN

is always true.

   After delay slot scheduling, some of the insns in the chain might be
`sequence' expressions, which contain a vector of insns.  The value of
`NEXT_INSN' in all but the last of these insns is the next insn in the
vector; the value of `NEXT_INSN' of the last insn in the vector is the
same as the value of `NEXT_INSN' for the `sequence' in which it is
contained.  Similar rules apply for `PREV_INSN'.

   This means that the above invariants are not necessarily true for
insns inside `sequence' expressions.  Specifically, if INSN is the
first insn in a `sequence', `NEXT_INSN (PREV_INSN (INSN))' is the insn
containing the `sequence' expression, as is the value of `PREV_INSN
(NEXT_INSN (INSN))' is INSN is the last insn in the `sequence'
expression.  You can use these expressions to find the containing
`sequence' expression.

   Every insn has one of the following six expression codes:

`insn'
     The expression code `insn' is used for instructions that do not
     jump and do not do function calls.  `sequence' expressions are
     always contained in insns with code `insn' even if one of those
     insns should jump or do function calls.

     Insns with code `insn' have four additional fields beyond the three
     mandatory ones listed above.  These four are described in a table
     below.

`jump_insn'
     The expression code `jump_insn' is used for instructions that may
     jump (or, more generally, may contain `label_ref' expressions).  If
     there is an instruction to return from the current function, it is
     recorded as a `jump_insn'.

     `jump_insn' insns have the same extra fields as `insn' insns,
     accessed in the same way and in addition contain a field
     `JUMP_LABEL' which is defined once jump optimization has completed.

     For simple conditional and unconditional jumps, this field
     contains the `code_label' to which this insn will (possibly
     conditionally) branch.  In a more complex jump, `JUMP_LABEL'
     records one of the labels that the insn refers to; the only way to
     find the others is to scan the entire body of the insn.

     Return insns count as jumps, but since they do not refer to any
     labels, they have zero in the `JUMP_LABEL' field.

`call_insn'
     The expression code `call_insn' is used for instructions that may
     do function calls.  It is important to distinguish these
     instructions because they imply that certain registers and memory
     locations may be altered unpredictably.

     `call_insn' insns have the same extra fields as `insn' insns,
     accessed in the same way and in addition contain a field
     `CALL_INSN_FUNCTION_USAGE', which contains a list (chain of
     `expr_list' expressions) containing `use' and `clobber'
     expressions that denote hard registers used or clobbered by the
     called function.  A register specified in a `clobber' in this list
     is modified _after_ the execution of the `call_insn', while a
     register in a `clobber' in the body of the `call_insn' is
     clobbered before the insn completes execution.  `clobber'
     expressions in this list augment registers specified in
     `CALL_USED_REGISTERS' (*note Register Basics::).

`code_label'
     A `code_label' insn represents a label that a jump insn can jump
     to.  It contains two special fields of data in addition to the
     three standard ones.  `CODE_LABEL_NUMBER' is used to hold the
     "label number", a number that identifies this label uniquely among
     all the labels in the compilation (not just in the current
     function).  Ultimately, the label is represented in the assembler
     output as an assembler label, usually of the form `LN' where N is
     the label number.

     When a `code_label' appears in an RTL expression, it normally
     appears within a `label_ref' which represents the address of the
     label, as a number.

     The field `LABEL_NUSES' is only defined once the jump optimization
     phase is completed and contains the number of times this label is
     referenced in the current function.

`barrier'
     Barriers are placed in the instruction stream when control cannot
     flow past them.  They are placed after unconditional jump
     instructions to indicate that the jumps are unconditional and
     after calls to `volatile' functions, which do not return (e.g.,
     `exit').  They contain no information beyond the three standard
     fields.

`note'
     `note' insns are used to represent additional debugging and
     declarative information.  They contain two nonstandard fields, an
     integer which is accessed with the macro `NOTE_LINE_NUMBER' and a
     string accessed with `NOTE_SOURCE_FILE'.

     If `NOTE_LINE_NUMBER' is positive, the note represents the
     position of a source line and `NOTE_SOURCE_FILE' is the source
     file name that the line came from.  These notes control generation
     of line number data in the assembler output.

     Otherwise, `NOTE_LINE_NUMBER' is not really a line number but a
     code with one of the following values (and `NOTE_SOURCE_FILE' must
     contain a null pointer):

    `NOTE_INSN_DELETED'
          Such a note is completely ignorable.  Some passes of the
          compiler delete insns by altering them into notes of this
          kind.

    `NOTE_INSN_BLOCK_BEG'
    `NOTE_INSN_BLOCK_END'
          These types of notes indicate the position of the beginning
          and end of a level of scoping of variable names.  They
          control the output of debugging information.

    `NOTE_INSN_EH_REGION_BEG'
    `NOTE_INSN_EH_REGION_END'
          These types of notes indicate the position of the beginning
          and end of a level of scoping for exception handling.
          `NOTE_BLOCK_NUMBER' identifies which `CODE_LABEL' is
          associated with the given region.

    `NOTE_INSN_LOOP_BEG'
    `NOTE_INSN_LOOP_END'
          These types of notes indicate the position of the beginning
          and end of a `while' or `for' loop.  They enable the loop
          optimizer to find loops quickly.

    `NOTE_INSN_LOOP_CONT'
          Appears at the place in a loop that `continue' statements
          jump to.

    `NOTE_INSN_LOOP_VTOP'
          This note indicates the place in a loop where the exit test
          begins for those loops in which the exit test has been
          duplicated.  This position becomes another virtual start of
          the loop when considering loop invariants.

    `NOTE_INSN_FUNCTION_END'
          Appears near the end of the function body, just before the
          label that `return' statements jump to (on machine where a
          single instruction does not suffice for returning).  This
          note may be deleted by jump optimization.

    `NOTE_INSN_SETJMP'
          Appears following each call to `setjmp' or a related function.

     These codes are printed symbolically when they appear in debugging
     dumps.

   The machine mode of an insn is normally `VOIDmode', but some phases
use the mode for various purposes.

   The common subexpression elimination pass sets the mode of an insn to
`QImode' when it is the first insn in a block that has already been
processed.

   The second Haifa scheduling pass, for targets that can multiple
issue, sets the mode of an insn to `TImode' when it is believed that the
instruction begins an issue group.  That is, when the instruction
cannot issue simultaneously with the previous.  This may be relied on
by later passes, in particular machine-dependant reorg.

   Here is a table of the extra fields of `insn', `jump_insn' and
`call_insn' insns:

`PATTERN (I)'
     An expression for the side effect performed by this insn.  This
     must be one of the following codes: `set', `call', `use',
     `clobber', `return', `asm_input', `asm_output', `addr_vec',
     `addr_diff_vec', `trap_if', `unspec', `unspec_volatile',
     `parallel', or `sequence'.  If it is a `parallel', each element of
     the `parallel' must be one these codes, except that `parallel'
     expressions cannot be nested and `addr_vec' and `addr_diff_vec'
     are not permitted inside a `parallel' expression.

`INSN_CODE (I)'
     An integer that says which pattern in the machine description
     matches this insn, or -1 if the matching has not yet been
     attempted.

     Such matching is never attempted and this field remains -1 on an
     insn whose pattern consists of a single `use', `clobber',
     `asm_input', `addr_vec' or `addr_diff_vec' expression.

     Matching is also never attempted on insns that result from an `asm'
     statement.  These contain at least one `asm_operands' expression.
     The function `asm_noperands' returns a non-negative value for such
     insns.

     In the debugging output, this field is printed as a number
     followed by a symbolic representation that locates the pattern in
     the `md' file as some small positive or negative offset from a
     named pattern.

`LOG_LINKS (I)'
     A list (chain of `insn_list' expressions) giving information about
     dependencies between instructions within a basic block.  Neither a
     jump nor a label may come between the related insns.

`REG_NOTES (I)'
     A list (chain of `expr_list' and `insn_list' expressions) giving
     miscellaneous information about the insn.  It is often information
     pertaining to the registers used in this insn.

   The `LOG_LINKS' field of an insn is a chain of `insn_list'
expressions.  Each of these has two operands: the first is an insn, and
the second is another `insn_list' expression (the next one in the
chain).  The last `insn_list' in the chain has a null pointer as second
operand.  The significant thing about the chain is which insns appear
in it (as first operands of `insn_list' expressions).  Their order is
not significant.

   This list is originally set up by the flow analysis pass; it is a
null pointer until then.  Flow only adds links for those data
dependencies which can be used for instruction combination.  For each
insn, the flow analysis pass adds a link to insns which store into
registers values that are used for the first time in this insn.  The
instruction scheduling pass adds extra links so that every dependence
will be represented.  Links represent data dependencies,
antidependencies and output dependencies; the machine mode of the link
distinguishes these three types: antidependencies have mode
`REG_DEP_ANTI', output dependencies have mode `REG_DEP_OUTPUT', and
data dependencies have mode `VOIDmode'.

   The `REG_NOTES' field of an insn is a chain similar to the
`LOG_LINKS' field but it includes `expr_list' expressions in addition
to `insn_list' expressions.  There are several kinds of register notes,
which are distinguished by the machine mode, which in a register note
is really understood as being an `enum reg_note'.  The first operand OP
of the note is data whose meaning depends on the kind of note.

   The macro `REG_NOTE_KIND (X)' returns the kind of register note.
Its counterpart, the macro `PUT_REG_NOTE_KIND (X, NEWKIND)' sets the
register note type of X to be NEWKIND.

   Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set of
values that are only used in `LOG_LINKS'.

   These register notes annotate inputs to an insn:

`REG_DEAD'
     The value in OP dies in this insn; that is to say, altering the
     value immediately after this insn would not affect the future
     behavior of the program.

     This does not necessarily mean that the register OP has no useful
     value after this insn since it may also be an output of the insn.
     In such a case, however, a `REG_DEAD' note would be redundant and
     is usually not present until after the reload pass, but no code
     relies on this fact.

`REG_INC'
     The register OP is incremented (or decremented; at this level
     there is no distinction) by an embedded side effect inside this
     insn.  This means it appears in a `post_inc', `pre_inc',
     `post_dec' or `pre_dec' expression.

`REG_NONNEG'
     The register OP is known to have a nonnegative value when this
     insn is reached.  This is used so that decrement and branch until
     zero instructions, such as the m68k dbra, can be matched.

     The `REG_NONNEG' note is added to insns only if the machine
     description has a `decrement_and_branch_until_zero' pattern.

`REG_NO_CONFLICT'
     This insn does not cause a conflict between OP and the item being
     set by this insn even though it might appear that it does.  In
     other words, if the destination register and OP could otherwise be
     assigned the same register, this insn does not prevent that
     assignment.

     Insns with this note are usually part of a block that begins with a
     `clobber' insn specifying a multi-word pseudo register (which will
     be the output of the block), a group of insns that each set one
     word of the value and have the `REG_NO_CONFLICT' note attached,
     and a final insn that copies the output to itself with an attached
     `REG_EQUAL' note giving the expression being computed.  This block
     is encapsulated with `REG_LIBCALL' and `REG_RETVAL' notes on the
     first and last insns, respectively.

`REG_LABEL'
     This insn uses OP, a `code_label', but is not a `jump_insn'.  The
     presence of this note allows jump optimization to be aware that OP
     is, in fact, being used.

   The following notes describe attributes of outputs of an insn:

`REG_EQUIV'
`REG_EQUAL'
     This note is only valid on an insn that sets only one register and
     indicates that that register will be equal to OP at run time; the
     scope of this equivalence differs between the two types of notes.
     The value which the insn explicitly copies into the register may
     look different from OP, but they will be equal at run time.  If the
     output of the single `set' is a `strict_low_part' expression, the
     note refers to the register that is contained in `SUBREG_REG' of
     the `subreg' expression.

     For `REG_EQUIV', the register is equivalent to OP throughout the
     entire function, and could validly be replaced in all its
     occurrences by OP.  ("Validly" here refers to the data flow of the
     program; simple replacement may make some insns invalid.)  For
     example, when a constant is loaded into a register that is never
     assigned any other value, this kind of note is used.

     When a parameter is copied into a pseudo-register at entry to a
     function, a note of this kind records that the register is
     equivalent to the stack slot where the parameter was passed.
     Although in this case the register may be set by other insns, it
     is still valid to replace the register by the stack slot
     throughout the function.

     A `REG_EQUIV' note is also used on an instruction which copies a
     register parameter into a pseudo-register at entry to a function,
     if there is a stack slot where that parameter could be stored.
     Although other insns may set the pseudo-register, it is valid for
     the compiler to replace the pseudo-register by stack slot
     throughout the function, provided the compiler ensures that the
     stack slot is properly initialized by making the replacement in
     the initial copy instruction as well.  This is used on machines
     for which the calling convention allocates stack space for
     register parameters.  See `REG_PARM_STACK_SPACE' in *note Stack
     Arguments::.

     In the case of `REG_EQUAL', the register that is set by this insn
     will be equal to OP at run time at the end of this insn but not
     necessarily elsewhere in the function.  In this case, OP is
     typically an arithmetic expression.  For example, when a sequence
     of insns such as a library call is used to perform an arithmetic
     operation, this kind of note is attached to the insn that produces
     or copies the final value.

     These two notes are used in different ways by the compiler passes.
     `REG_EQUAL' is used by passes prior to register allocation (such as
     common subexpression elimination and loop optimization) to tell
     them how to think of that value.  `REG_EQUIV' notes are used by
     register allocation to indicate that there is an available
     substitute expression (either a constant or a `mem' expression for
     the location of a parameter on the stack) that may be used in
     place of a register if insufficient registers are available.

     Except for stack homes for parameters, which are indicated by a
     `REG_EQUIV' note and are not useful to the early optimization
     passes and pseudo registers that are equivalent to a memory
     location throughout there entire life, which is not detected until
     later in the compilation, all equivalences are initially indicated
     by an attached `REG_EQUAL' note.  In the early stages of register
     allocation, a `REG_EQUAL' note is changed into a `REG_EQUIV' note
     if OP is a constant and the insn represents the only set of its
     destination register.

     Thus, compiler passes prior to register allocation need only check
     for `REG_EQUAL' notes and passes subsequent to register allocation
     need only check for `REG_EQUIV' notes.

`REG_UNUSED'
     The register OP being set by this insn will not be used in a
     subsequent insn.  This differs from a `REG_DEAD' note, which
     indicates that the value in an input will not be used subsequently.
     These two notes are independent; both may be present for the same
     register.

`REG_WAS_0'
     The single output of this insn contained zero before this insn.
     OP is the insn that set it to zero.  You can rely on this note if
     it is present and OP has not been deleted or turned into a `note';
     its absence implies nothing.

   These notes describe linkages between insns.  They occur in pairs:
one insn has one of a pair of notes that points to a second insn, which
has the inverse note pointing back to the first insn.

`REG_RETVAL'
     This insn copies the value of a multi-insn sequence (for example, a
     library call), and OP is the first insn of the sequence (for a
     library call, the first insn that was generated to set up the
     arguments for the library call).

     Loop optimization uses this note to treat such a sequence as a
     single operation for code motion purposes and flow analysis uses
     this note to delete such sequences whose results are dead.

     A `REG_EQUAL' note will also usually be attached to this insn to
     provide the expression being computed by the sequence.

     These notes will be deleted after reload, since they are no longer
     accurate or useful.

`REG_LIBCALL'
     This is the inverse of `REG_RETVAL': it is placed on the first
     insn of a multi-insn sequence, and it points to the last one.

     These notes are deleted after reload, since they are no longer
     useful or accurate.

`REG_CC_SETTER'
`REG_CC_USER'
     On machines that use `cc0', the insns which set and use `cc0' set
     and use `cc0' are adjacent.  However, when branch delay slot
     filling is done, this may no longer be true.  In this case a
     `REG_CC_USER' note will be placed on the insn setting `cc0' to
     point to the insn using `cc0' and a `REG_CC_SETTER' note will be
     placed on the insn using `cc0' to point to the insn setting `cc0'.

   These values are only used in the `LOG_LINKS' field, and indicate
the type of dependency that each link represents.  Links which indicate
a data dependence (a read after write dependence) do not use any code,
they simply have mode `VOIDmode', and are printed without any
descriptive text.

`REG_DEP_ANTI'
     This indicates an anti dependence (a write after read dependence).

`REG_DEP_OUTPUT'
     This indicates an output dependence (a write after write
     dependence).

   These notes describe information gathered from gcov profile data.
They are stored in the `REG_NOTES' field of an insn as an `expr_list'.

`REG_EXEC_COUNT'
     This is used to indicate the number of times a basic block was
     executed according to the profile data.  The note is attached to
     the first insn in the basic block.

`REG_BR_PROB'
     This is used to specify the ratio of branches to non-branches of a
     branch insn according to the profile data.  The value is stored as
     a value between 0 and REG_BR_PROB_BASE; larger values indicate a
     higher probability that the branch will be taken.

`REG_BR_PRED'
     These notes are found in JUMP insns after delayed branch scheduling
     has taken place.  They indicate both the direction and the
     likelyhood of the JUMP.  The format is a bitmask of ATTR_FLAG_*
     values.

`REG_FRAME_RELATED_EXPR'
     This is used on an RTX_FRAME_RELATED_P insn wherein the attached
     expression is used in place of the actual insn pattern.  This is
     done in cases where the pattern is either complex or misleading.

   For convenience, the machine mode in an `insn_list' or `expr_list'
is printed using these symbolic codes in debugging dumps.

   The only difference between the expression codes `insn_list' and
`expr_list' is that the first operand of an `insn_list' is assumed to
be an insn and is printed in debugging dumps as the insn's unique id;
the first operand of an `expr_list' is printed in the ordinary way as
an expression.


File: gcc.info,  Node: Calls,  Next: Sharing,  Prev: Insns,  Up: RTL

15.17 RTL Representation of Function-Call Insns
===============================================

Insns that call subroutines have the RTL expression code `call_insn'.
These insns must satisfy special rules, and their bodies must use a
special RTL expression code, `call'.

   A `call' expression has two operands, as follows:

     (call (mem:FM ADDR) NBYTES)

Here NBYTES is an operand that represents the number of bytes of
argument data being passed to the subroutine, FM is a machine mode
(which must equal as the definition of the `FUNCTION_MODE' macro in the
machine description) and ADDR represents the address of the subroutine.

   For a subroutine that returns no value, the `call' expression as
shown above is the entire body of the insn, except that the insn might
also contain `use' or `clobber' expressions.

   For a subroutine that returns a value whose mode is not `BLKmode',
the value is returned in a hard register.  If this register's number is
R, then the body of the call insn looks like this:

     (set (reg:M R)
          (call (mem:FM ADDR) NBYTES))

This RTL expression makes it clear (to the optimizer passes) that the
appropriate register receives a useful value in this insn.

   When a subroutine returns a `BLKmode' value, it is handled by
passing to the subroutine the address of a place to store the value.
So the call insn itself does not "return" any value, and it has the
same RTL form as a call that returns nothing.

   On some machines, the call instruction itself clobbers some register,
for example to contain the return address.  `call_insn' insns on these
machines should have a body which is a `parallel' that contains both
the `call' expression and `clobber' expressions that indicate which
registers are destroyed.  Similarly, if the call instruction requires
some register other than the stack pointer that is not explicitly
mentioned it its RTL, a `use' subexpression should mention that
register.

   Functions that are called are assumed to modify all registers listed
in the configuration macro `CALL_USED_REGISTERS' (*note Register
Basics::) and, with the exception of `const' functions and library
calls, to modify all of memory.

   Insns containing just `use' expressions directly precede the
`call_insn' insn to indicate which registers contain inputs to the
function.  Similarly, if registers other than those in
`CALL_USED_REGISTERS' are clobbered by the called function, insns
containing a single `clobber' follow immediately after the call to
indicate which registers.


File: gcc.info,  Node: Sharing,  Next: Reading RTL,  Prev: Calls,  Up: RTL

15.18 Structure Sharing Assumptions
===================================

The compiler assumes that certain kinds of RTL expressions are unique;
there do not exist two distinct objects representing the same value.
In other cases, it makes an opposite assumption: that no RTL expression
object of a certain kind appears in more than one place in the
containing structure.

   These assumptions refer to a single function; except for the RTL
objects that describe global variables and external functions, and a
few standard objects such as small integer constants, no RTL objects
are common to two functions.

   * Each pseudo-register has only a single `reg' object to represent
     it, and therefore only a single machine mode.

   * For any symbolic label, there is only one `symbol_ref' object
     referring to it.

   * There is only one `const_int' expression with value 0, only one
     with value 1, and only one with value -1.  Some other integer
     values are also stored uniquely.

   * There is only one `pc' expression.

   * There is only one `cc0' expression.

   * There is only one `const_double' expression with value 0 for each
     floating point mode.  Likewise for values 1 and 2.

   * No `label_ref' or `scratch' appears in more than one place in the
     RTL structure; in other words, it is safe to do a tree-walk of all
     the insns in the function and assume that each time a `label_ref'
     or `scratch' is seen it is distinct from all others that are seen.

   * Only one `mem' object is normally created for each static variable
     or stack slot, so these objects are frequently shared in all the
     places they appear.  However, separate but equal objects for these
     variables are occasionally made.

   * When a single `asm' statement has multiple output operands, a
     distinct `asm_operands' expression is made for each output operand.
     However, these all share the vector which contains the sequence of
     input operands.  This sharing is used later on to test whether two
     `asm_operands' expressions come from the same statement, so all
     optimizations must carefully preserve the sharing if they copy the
     vector at all.

   * No RTL object appears in more than one place in the RTL structure
     except as described above.  Many passes of the compiler rely on
     this by assuming that they can modify RTL objects in place without
     unwanted side-effects on other insns.

   * During initial RTL generation, shared structure is freely
     introduced.  After all the RTL for a function has been generated,
     all shared structure is copied by `unshare_all_rtl' in
     `emit-rtl.c', after which the above rules are guaranteed to be
     followed.

   * During the combiner pass, shared structure within an insn can exist
     temporarily.  However, the shared structure is copied before the
     combiner is finished with the insn.  This is done by calling
     `copy_rtx_if_shared', which is a subroutine of `unshare_all_rtl'.


File: gcc.info,  Node: Reading RTL,  Prev: Sharing,  Up: RTL

15.19 Reading RTL
=================

To read an RTL object from a file, call `read_rtx'.  It takes one
argument, a stdio stream, and returns a single RTL object.

   Reading RTL from a file is very slow.  This is not currently a
problem since reading RTL occurs only as part of building the compiler.

   People frequently have the idea of using RTL stored as text in a
file as an interface between a language front end and the bulk of GNU
CC.  This idea is not feasible.

   GNU CC was designed to use RTL internally only.  Correct RTL for a
given program is very dependent on the particular target machine.  And
the RTL does not contain all the information about the program.

   The proper way to interface GNU CC to a new language front end is
with the "tree" data structure.  There is no manual for this data
structure, but it is described in the files `tree.h' and `tree.def'.


File: gcc.info,  Node: Machine Desc,  Next: Target Macros,  Prev: RTL,  Up: Top

16 Machine Descriptions
***********************

A machine description has two parts: a file of instruction patterns
(`.md' file) and a C header file of macro definitions.

   The `.md' file for a target machine contains a pattern for each
instruction that the target machine supports (or at least each
instruction that is worth telling the compiler about).  It may also
contain comments.  A semicolon causes the rest of the line to be a
comment, unless the semicolon is inside a quoted string.

   See the next chapter for information on the C header file.

* Menu:

* Patterns::            How to write instruction patterns.
* Example::             An explained example of a `define_insn' pattern.
* RTL Template::        The RTL template defines what insns match a pattern.
* Output Template::     The output template says how to make assembler code
                          from such an insn.
* Output Statement::    For more generality, write C code to output
                          the assembler code.
* Constraints::         When not all operands are general operands.
* Standard Names::      Names mark patterns to use for code generation.
* Pattern Ordering::    When the order of patterns makes a difference.
* Dependent Patterns::  Having one pattern may make you need another.
* Jump Patterns::       Special considerations for patterns for jump insns.
* Insn Canonicalizations::Canonicalization of Instructions
* Peephole Definitions::Defining machine-specific peephole optimizations.
* Expander Definitions::Generating a sequence of several RTL insns
                         for a standard operation.
* Insn Splitting::    Splitting Instructions into Multiple Instructions
* Insn Attributes::     Specifying the value of attributes for generated insns.


File: gcc.info,  Node: Patterns,  Next: Example,  Up: Machine Desc

16.1 Everything about Instruction Patterns
==========================================

Each instruction pattern contains an incomplete RTL expression, with
pieces to be filled in later, operand constraints that restrict how the
pieces can be filled in, and an output pattern or C code to generate
the assembler output, all wrapped up in a `define_insn' expression.

   A `define_insn' is an RTL expression containing four or five
operands:

  1. An optional name.  The presence of a name indicate that this
     instruction pattern can perform a certain standard job for the
     RTL-generation pass of the compiler.  This pass knows certain
     names and will use the instruction patterns with those names, if
     the names are defined in the machine description.

     The absence of a name is indicated by writing an empty string
     where the name should go.  Nameless instruction patterns are never
     used for generating RTL code, but they may permit several simpler
     insns to be combined later on.

     Names that are not thus known and used in RTL-generation have no
     effect; they are equivalent to no name at all.

  2. The "RTL template" (*note RTL Template::) is a vector of incomplete
     RTL expressions which show what the instruction should look like.
     It is incomplete because it may contain `match_operand',
     `match_operator', and `match_dup' expressions that stand for
     operands of the instruction.

     If the vector has only one element, that element is the template
     for the instruction pattern.  If the vector has multiple elements,
     then the instruction pattern is a `parallel' expression containing
     the elements described.

  3. A condition.  This is a string which contains a C expression that
     is the final test to decide whether an insn body matches this
     pattern.

     For a named pattern, the condition (if present) may not depend on
     the data in the insn being matched, but only the
     target-machine-type flags.  The compiler needs to test these
     conditions during initialization in order to learn exactly which
     named instructions are available in a particular run.

     For nameless patterns, the condition is applied only when matching
     an individual insn, and only after the insn has matched the
     pattern's recognition template.  The insn's operands may be found
     in the vector `operands'.

  4. The "output template": a string that says how to output matching
     insns as assembler code.  `%' in this string specifies where to
     substitute the value of an operand.  *Note Output Template::.

     When simple substitution isn't general enough, you can specify a
     piece of C code to compute the output.  *Note Output Statement::.

  5. Optionally, a vector containing the values of attributes for insns
     matching this pattern.  *Note Insn Attributes::.


File: gcc.info,  Node: Example,  Next: RTL Template,  Prev: Patterns,  Up: Machine Desc

16.2 Example of `define_insn'
=============================

Here is an actual example of an instruction pattern, for the
68000/68020.

     (define_insn "tstsi"
       [(set (cc0)
             (match_operand:SI 0 "general_operand" "rm"))]
       ""
       "*
     { if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
         return \"tstl %0\";
       return \"cmpl #0,%0\"; }")

   This is an instruction that sets the condition codes based on the
value of a general operand.  It has no condition, so any insn whose RTL
description has the form shown may be handled according to this
pattern.  The name `tstsi' means "test a `SImode' value" and tells the
RTL generation pass that, when it is necessary to test such a value, an
insn to do so can be constructed using this pattern.

   The output control string is a piece of C code which chooses which
output template to return based on the kind of operand and the specific
type of CPU for which code is being generated.

   `"rm"' is an operand constraint.  Its meaning is explained below.


File: gcc.info,  Node: RTL Template,  Next: Output Template,  Prev: Example,  Up: Machine Desc

16.3 RTL Template
=================

The RTL template is used to define which insns match the particular
pattern and how to find their operands.  For named patterns, the RTL
template also says how to construct an insn from specified operands.

   Construction involves substituting specified operands into a copy of
the template.  Matching involves determining the values that serve as
the operands in the insn being matched.  Both of these activities are
controlled by special expression types that direct matching and
substitution of the operands.

`(match_operand:M N PREDICATE CONSTRAINT)'
     This expression is a placeholder for operand number N of the insn.
     When constructing an insn, operand number N will be substituted at
     this point.  When matching an insn, whatever appears at this
     position in the insn will be taken as operand number N; but it
     must satisfy PREDICATE or this instruction pattern will not match
     at all.

     Operand numbers must be chosen consecutively counting from zero in
     each instruction pattern.  There may be only one `match_operand'
     expression in the pattern for each operand number.  Usually
     operands are numbered in the order of appearance in `match_operand'
     expressions.  In the case of a `define_expand', any operand numbers
     used only in `match_dup' expressions have higher values than all
     other operand numbers.

     PREDICATE is a string that is the name of a C function that
     accepts two arguments, an expression and a machine mode.  During
     matching, the function will be called with the putative operand as
     the expression and M as the mode argument (if M is not specified,
     `VOIDmode' will be used, which normally causes PREDICATE to accept
     any mode).  If it returns zero, this instruction pattern fails to
     match.  PREDICATE may be an empty string; then it means no test is
     to be done on the operand, so anything which occurs in this
     position is valid.

     Most of the time, PREDICATE will reject modes other than M--but
     not always.  For example, the predicate `address_operand' uses M
     as the mode of memory ref that the address should be valid for.
     Many predicates accept `const_int' nodes even though their mode is
     `VOIDmode'.

     CONSTRAINT controls reloading and the choice of the best register
     class to use for a value, as explained later (*note Constraints::).

     People are often unclear on the difference between the constraint
     and the predicate.  The predicate helps decide whether a given
     insn matches the pattern.  The constraint plays no role in this
     decision; instead, it controls various decisions in the case of an
     insn which does match.

     On CISC machines, the most common PREDICATE is
     `"general_operand"'.  This function checks that the putative
     operand is either a constant, a register or a memory reference,
     and that it is valid for mode M.

     For an operand that must be a register, PREDICATE should be
     `"register_operand"'.  Using `"general_operand"' would be valid,
     since the reload pass would copy any non-register operands through
     registers, but this would make GNU CC do extra work, it would
     prevent invariant operands (such as constant) from being removed
     from loops, and it would prevent the register allocator from doing
     the best possible job.  On RISC machines, it is usually most
     efficient to allow PREDICATE to accept only objects that the
     constraints allow.

     For an operand that must be a constant, you must be sure to either
     use `"immediate_operand"' for PREDICATE, or make the instruction
     pattern's extra condition require a constant, or both.  You cannot
     expect the constraints to do this work!  If the constraints allow
     only constants, but the predicate allows something else, the
     compiler will crash when that case arises.

`(match_scratch:M N CONSTRAINT)'
     This expression is also a placeholder for operand number N and
     indicates that operand must be a `scratch' or `reg' expression.

     When matching patterns, this is equivalent to

          (match_operand:M N "scratch_operand" PRED)

     but, when generating RTL, it produces a (`scratch':M) expression.

     If the last few expressions in a `parallel' are `clobber'
     expressions whose operands are either a hard register or
     `match_scratch', the combiner can add or delete them when
     necessary.  *Note Side Effects::.

`(match_dup N)'
     This expression is also a placeholder for operand number N.  It is
     used when the operand needs to appear more than once in the insn.

     In construction, `match_dup' acts just like `match_operand': the
     operand is substituted into the insn being constructed.  But in
     matching, `match_dup' behaves differently.  It assumes that operand
     number N has already been determined by a `match_operand'
     appearing earlier in the recognition template, and it matches only
     an identical-looking expression.

`(match_operator:M N PREDICATE [OPERANDS...])'
     This pattern is a kind of placeholder for a variable RTL expression
     code.

     When constructing an insn, it stands for an RTL expression whose
     expression code is taken from that of operand N, and whose
     operands are constructed from the patterns OPERANDS.

     When matching an expression, it matches an expression if the
     function PREDICATE returns nonzero on that expression _and_ the
     patterns OPERANDS match the operands of the expression.

     Suppose that the function `commutative_operator' is defined as
     follows, to match any expression whose operator is one of the
     commutative arithmetic operators of RTL and whose mode is MODE:

          int
          commutative_operator (x, mode)
               rtx x;
               enum machine_mode mode;
          {
            enum rtx_code code = GET_CODE (x);
            if (GET_MODE (x) != mode)
              return 0;
            return (GET_RTX_CLASS (code) == 'c'
                    || code == EQ || code == NE);
          }

     Then the following pattern will match any RTL expression consisting
     of a commutative operator applied to two general operands:

          (match_operator:SI 3 "commutative_operator"
            [(match_operand:SI 1 "general_operand" "g")
             (match_operand:SI 2 "general_operand" "g")])

     Here the vector `[OPERANDS...]' contains two patterns because the
     expressions to be matched all contain two operands.

     When this pattern does match, the two operands of the commutative
     operator are recorded as operands 1 and 2 of the insn.  (This is
     done by the two instances of `match_operand'.)  Operand 3 of the
     insn will be the entire commutative expression: use `GET_CODE
     (operands[3])' to see which commutative operator was used.

     The machine mode M of `match_operator' works like that of
     `match_operand': it is passed as the second argument to the
     predicate function, and that function is solely responsible for
     deciding whether the expression to be matched "has" that mode.

     When constructing an insn, argument 3 of the gen-function will
     specify the operation (i.e. the expression code) for the
     expression to be made.  It should be an RTL expression, whose
     expression code is copied into a new expression whose operands are
     arguments 1 and 2 of the gen-function.  The subexpressions of
     argument 3 are not used; only its expression code matters.

     When `match_operator' is used in a pattern for matching an insn,
     it usually best if the operand number of the `match_operator' is
     higher than that of the actual operands of the insn.  This improves
     register allocation because the register allocator often looks at
     operands 1 and 2 of insns to see if it can do register tying.

     There is no way to specify constraints in `match_operator'.  The
     operand of the insn which corresponds to the `match_operator'
     never has any constraints because it is never reloaded as a whole.
     However, if parts of its OPERANDS are matched by `match_operand'
     patterns, those parts may have constraints of their own.

`(match_op_dup:M N[OPERANDS...])'
     Like `match_dup', except that it applies to operators instead of
     operands.  When constructing an insn, operand number N will be
     substituted at this point.  But in matching, `match_op_dup' behaves
     differently.  It assumes that operand number N has already been
     determined by a `match_operator' appearing earlier in the
     recognition template, and it matches only an identical-looking
     expression.

`(match_parallel N PREDICATE [SUBPAT...])'
     This pattern is a placeholder for an insn that consists of a
     `parallel' expression with a variable number of elements.  This
     expression should only appear at the top level of an insn pattern.

     When constructing an insn, operand number N will be substituted at
     this point.  When matching an insn, it matches if the body of the
     insn is a `parallel' expression with at least as many elements as
     the vector of SUBPAT expressions in the `match_parallel', if each
     SUBPAT matches the corresponding element of the `parallel', _and_
     the function PREDICATE returns nonzero on the `parallel' that is
     the body of the insn.  It is the responsibility of the predicate
     to validate elements of the `parallel' beyond those listed in the
     `match_parallel'.

     A typical use of `match_parallel' is to match load and store
     multiple expressions, which can contain a variable number of
     elements in a `parallel'.  For example,

          (define_insn ""
            [(match_parallel 0 "load_multiple_operation"
               [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
                     (match_operand:SI 2 "memory_operand" "m"))
                (use (reg:SI 179))
                (clobber (reg:SI 179))])]
            ""
            "loadm 0,0,%1,%2")

     This example comes from `a29k.md'.  The function
     `load_multiple_operations' is defined in `a29k.c' and checks that
     subsequent elements in the `parallel' are the same as the `set' in
     the pattern, except that they are referencing subsequent registers
     and memory locations.

     An insn that matches this pattern might look like:

          (parallel
           [(set (reg:SI 20) (mem:SI (reg:SI 100)))
            (use (reg:SI 179))
            (clobber (reg:SI 179))
            (set (reg:SI 21)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 4))))
            (set (reg:SI 22)
                 (mem:SI (plus:SI (reg:SI 100)
                                  (const_int 8))))])

`(match_par_dup N [SUBPAT...])'
     Like `match_op_dup', but for `match_parallel' instead of
     `match_operator'.

`(match_insn PREDICATE)'
     Match a complete insn.  Unlike the other `match_*' recognizers,
     `match_insn' does not take an operand number.

     The machine mode M of `match_insn' works like that of
     `match_operand': it is passed as the second argument to the
     predicate function, and that function is solely responsible for
     deciding whether the expression to be matched "has" that mode.

`(match_insn2 N PREDICATE)'
     Match a complete insn.

     The machine mode M of `match_insn2' works like that of
     `match_operand': it is passed as the second argument to the
     predicate function, and that function is solely responsible for
     deciding whether the expression to be matched "has" that mode.

`(address (match_operand:M N "address_operand" ""))'
     This complex of expressions is a placeholder for an operand number
     N in a "load address" instruction: an operand which specifies a
     memory location in the usual way, but for which the actual operand
     value used is the address of the location, not the contents of the
     location.

     `address' expressions never appear in RTL code, only in machine
     descriptions.  And they are used only in machine descriptions that
     do not use the operand constraint feature.  When operand
     constraints are in use, the letter `p' in the constraint serves
     this purpose.

     M is the machine mode of the _memory location being addressed_,
     not the machine mode of the address itself.  That mode is always
     the same on a given target machine (it is `Pmode', which normally
     is `SImode'), so there is no point in mentioning it; thus, no
     machine mode is written in the `address' expression.  If some day
     support is added for machines in which addresses of different
     kinds of objects appear differently or are used differently (such
     as the PDP-10), different formats would perhaps need different
     machine modes and these modes might be written in the `address'
     expression.


File: gcc.info,  Node: Output Template,  Next: Output Statement,  Prev: RTL Template,  Up: Machine Desc

16.4 Output Templates and Operand Substitution
==============================================

The "output template" is a string which specifies how to output the
assembler code for an instruction pattern.  Most of the template is a
fixed string which is output literally.  The character `%' is used to
specify where to substitute an operand; it can also be used to identify
places where different variants of the assembler require different
syntax.

   In the simplest case, a `%' followed by a digit N says to output
operand N at that point in the string.

   `%' followed by a letter and a digit says to output an operand in an
alternate fashion.  Four letters have standard, built-in meanings
described below.  The machine description macro `PRINT_OPERAND' can
define additional letters with nonstandard meanings.

   `%cDIGIT' can be used to substitute an operand that is a constant
value without the syntax that normally indicates an immediate operand.

   `%nDIGIT' is like `%cDIGIT' except that the value of the constant is
negated before printing.

   `%aDIGIT' can be used to substitute an operand as if it were a
memory reference, with the actual operand treated as the address.  This
may be useful when outputting a "load address" instruction, because
often the assembler syntax for such an instruction requires you to
write the operand as if it were a memory reference.

   `%lDIGIT' is used to substitute a `label_ref' into a jump
instruction.

   `%=' outputs a number which is unique to each instruction in the
entire compilation.  This is useful for making local labels to be
referred to more than once in a single template that generates multiple
assembler instructions.

   `%' followed by a punctuation character specifies a substitution that
does not use an operand.  Only one case is standard: `%%' outputs a `%'
into the assembler code.  Other nonstandard cases can be defined in the
`PRINT_OPERAND' macro.  You must also define which punctuation
characters are valid with the `PRINT_OPERAND_PUNCT_VALID_P' macro.

   The template may generate multiple assembler instructions.  Write
the text for the instructions, with `\;' between them.

   When the RTL contains two operands which are required by constraint
to match each other, the output template must refer only to the
lower-numbered operand.  Matching operands are not always identical,
and the rest of the compiler arranges to put the proper RTL expression
for printing into the lower-numbered operand.

   One use of nonstandard letters or punctuation following `%' is to
distinguish between different assembler languages for the same machine;
for example, Motorola syntax versus MIT syntax for the 68000.  Motorola
syntax requires periods in most opcode names, while MIT syntax does
not.  For example, the opcode `movel' in MIT syntax is `move.l' in
Motorola syntax.  The same file of patterns is used for both kinds of
output syntax, but the character sequence `%.' is used in each place
where Motorola syntax wants a period.  The `PRINT_OPERAND' macro for
Motorola syntax defines the sequence to output a period; the macro for
MIT syntax defines it to do nothing.

   As a special case, a template consisting of the single character `#'
instructs the compiler to first split the insn, and then output the
resulting instructions separately.  This helps eliminate redundancy in
the output templates.   If you have a `define_insn' that needs to emit
multiple assembler instructions, and there is an matching `define_split'
already defined, then you can simply use `#' as the output template
instead of writing an output template that emits the multiple assembler
instructions.

   If the macro `ASSEMBLER_DIALECT' is defined, you can use construct
of the form `{option0|option1|option2}' in the templates.  These
describe multiple variants of assembler language syntax.  *Note
Instruction Output::.


File: gcc.info,  Node: Output Statement,  Next: Constraints,  Prev: Output Template,  Up: Machine Desc

16.5 C Statements for Assembler Output
======================================

Often a single fixed template string cannot produce correct and
efficient assembler code for all the cases that are recognized by a
single instruction pattern.  For example, the opcodes may depend on the
kinds of operands; or some unfortunate combinations of operands may
require extra machine instructions.

   If the output control string starts with a `@', then it is actually
a series of templates, each on a separate line.  (Blank lines and
leading spaces and tabs are ignored.)  The templates correspond to the
pattern's constraint alternatives (*note Multi-Alternative::).  For
example, if a target machine has a two-address add instruction `addr'
to add into a register and another `addm' to add a register to memory,
you might write this pattern:

     (define_insn "addsi3"
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (plus:SI (match_operand:SI 1 "general_operand" "0,0")
                      (match_operand:SI 2 "general_operand" "g,r")))]
       ""
       "@
        addr %2,%0
        addm %2,%0")

   If the output control string starts with a `*', then it is not an
output template but rather a piece of C program that should compute a
template.  It should execute a `return' statement to return the
template-string you want.  Most such templates use C string literals,
which require doublequote characters to delimit them.  To include these
doublequote characters in the string, prefix each one with `\'.

   The operands may be found in the array `operands', whose C data type
is `rtx []'.

   It is very common to select different ways of generating assembler
code based on whether an immediate operand is within a certain range.
Be careful when doing this, because the result of `INTVAL' is an
integer on the host machine.  If the host machine has more bits in an
`int' than the target machine has in the mode in which the constant
will be used, then some of the bits you get from `INTVAL' will be
superfluous.  For proper results, you must carefully disregard the
values of those bits.

   It is possible to output an assembler instruction and then go on to
output or compute more of them, using the subroutine `output_asm_insn'.
This receives two arguments: a template-string and a vector of
operands.  The vector may be `operands', or it may be another array of
`rtx' that you declare locally and initialize yourself.

   When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code is determined mostly by
which alternative was matched.  When this is so, the C code can test
the variable `which_alternative', which is the ordinal number of the
alternative that was actually satisfied (0 for the first, 1 for the
second alternative, etc.).

   For example, suppose there are two opcodes for storing zero, `clrreg'
for registers and `clrmem' for memory locations.  Here is how a pattern
could use `which_alternative' to choose between them:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (const_int 0))]
       ""
       "*
       return (which_alternative == 0
               ? \"clrreg %0\" : \"clrmem %0\");
       ")

   The example above, where the assembler code to generate was _solely_
determined by the alternative, could also have been specified as
follows, having the output control string start with a `@':

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,m")
             (const_int 0))]
       ""
       "@
        clrreg %0
        clrmem %0")


File: gcc.info,  Node: Constraints,  Next: Standard Names,  Prev: Output Statement,  Up: Machine Desc

16.6 Operand Constraints
========================

Each `match_operand' in an instruction pattern can specify a constraint
for the type of operands allowed.  Constraints can say whether an
operand may be in a register, and which kinds of register; whether the
operand can be a memory reference, and which kinds of address; whether
the operand may be an immediate constant, and which possible values it
may have.  Constraints can also require two operands to match.

* Menu:

* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Class Preferences::   Constraints guide which hard register to put things in.
* Modifiers::           More precise control over effects of constraints.
* Machine Constraints:: Existing constraints for some particular machines.
* No Constraints::      Describing a clean machine without constraints.


File: gcc.info,  Node: Simple Constraints,  Next: Multi-Alternative,  Up: Constraints

16.6.1 Simple Constraints
-------------------------

The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are the
letters that are allowed:

`m'
     A memory operand is allowed, with any kind of address that the
     machine supports in general.

`o'
     A memory operand is allowed, but only if the address is
     "offsettable".  This means that adding a small integer (actually,
     the width in bytes of the operand, as determined by its machine
     mode) may be added to the address and the result is also a valid
     memory address.

     For example, an address which is constant is offsettable; so is an
     address that is the sum of a register and a constant (as long as a
     slightly larger constant is also within the range of
     address-offsets supported by the machine); but an autoincrement or
     autodecrement address is not offsettable.  More complicated
     indirect/indexed addresses may or may not be offsettable depending
     on the other addressing modes that the machine supports.

     Note that in an output operand which can be matched by another
     operand, the constraint letter `o' is valid only when accompanied
     by both `<' (if the target machine has predecrement addressing)
     and `>' (if the target machine has preincrement addressing).

`V'
     A memory operand that is not offsettable.  In other words,
     anything that would fit the `m' constraint but not the `o'
     constraint.

`<'
     A memory operand with autodecrement addressing (either
     predecrement or postdecrement) is allowed.

`>'
     A memory operand with autoincrement addressing (either
     preincrement or postincrement) is allowed.

`r'
     A register operand is allowed provided that it is in a general
     register.

`d', `a', `f', ...
     Other letters can be defined in machine-dependent fashion to stand
     for particular classes of registers.  `d', `a' and `f' are defined
     on the 68000/68020 to stand for data, address and floating point
     registers.

`i'
     An immediate integer operand (one with constant value) is allowed.
     This includes symbolic constants whose values will be known only at
     assembly time.

`n'
     An immediate integer operand with a known numeric value is allowed.
     Many systems cannot support assembly-time constants for operands
     less than a word wide.  Constraints for these operands should use
     `n' rather than `i'.

`I', `J', `K', ... `P'
     Other letters in the range `I' through `P' may be defined in a
     machine-dependent fashion to permit immediate integer operands with
     explicit integer values in specified ranges.  For example, on the
     68000, `I' is defined to stand for the range of values 1 to 8.
     This is the range permitted as a shift count in the shift
     instructions.

`E'
     An immediate floating operand (expression code `const_double') is
     allowed, but only if the target floating point format is the same
     as that of the host machine (on which the compiler is running).

`F'
     An immediate floating operand (expression code `const_double') is
     allowed.

`G', `H'
     `G' and `H' may be defined in a machine-dependent fashion to
     permit immediate floating operands in particular ranges of values.

`s'
     An immediate integer operand whose value is not an explicit
     integer is allowed.

     This might appear strange; if an insn allows a constant operand
     with a value not known at compile time, it certainly must allow
     any known value.  So why use `s' instead of `i'?  Sometimes it
     allows better code to be generated.

     For example, on the 68000 in a fullword instruction it is possible
     to use an immediate operand; but if the immediate value is between
     -128 and 127, better code results from loading the value into a
     register and using the register.  This is because the load into
     the register can be done with a `moveq' instruction.  We arrange
     for this to happen by defining the letter `K' to mean "any integer
     outside the range -128 to 127", and then specifying `Ks' in the
     operand constraints.

`g'
     Any register, memory or immediate integer operand is allowed,
     except for registers that are not general registers.

`X'
     Any operand whatsoever is allowed, even if it does not satisfy
     `general_operand'.  This is normally used in the constraint of a
     `match_scratch' when certain alternatives will not actually
     require a scratch register.

`0', `1', `2', ... `9'
     An operand that matches the specified operand number is allowed.
     If a digit is used together with letters within the same
     alternative, the digit should come last.

     This is called a "matching constraint" and what it really means is
     that the assembler has only a single operand that fills two roles
     considered separate in the RTL insn.  For example, an add insn has
     two input operands and one output operand in the RTL, but on most
     CISC machines an add instruction really has only two operands, one
     of them an input-output operand:

          addl #35,r12

     Matching constraints are used in these circumstances.  More
     precisely, the two operands that match must include one input-only
     operand and one output-only operand.  Moreover, the digit must be a
     smaller number than the number of the operand that uses it in the
     constraint.

     For operands to match in a particular case usually means that they
     are identical-looking RTL expressions.  But in a few special cases
     specific kinds of dissimilarity are allowed.  For example, `*x' as
     an input operand will match `*x++' as an output operand.  For
     proper results in such cases, the output template should always
     use the output-operand's number when printing the operand.

`p'
     An operand that is a valid memory address is allowed.  This is for
     "load address" and "push address" instructions.

     `p' in the constraint must be accompanied by `address_operand' as
     the predicate in the `match_operand'.  This predicate interprets
     the mode specified in the `match_operand' as the mode of the memory
     reference for which the address would be valid.

`Q', `R', `S', ... `U'
     Letters in the range `Q' through `U' may be defined in a
     machine-dependent fashion to stand for arbitrary operand types.
     The machine description macro `EXTRA_CONSTRAINT' is passed the
     operand as its first argument and the constraint letter as its
     second operand.

     A typical use for this would be to distinguish certain types of
     memory references that affect other insn operands.

     Do not define these constraint letters to accept register
     references (`reg'); the reload pass does not expect this and would
     not handle it properly.

   In order to have valid assembler code, each operand must satisfy its
constraint.  But a failure to do so does not prevent the pattern from
applying to an insn.  Instead, it directs the compiler to modify the
code so that the constraint will be satisfied.  Usually this is done by
copying an operand into a register.

   Contrast, therefore, the two instruction patterns that follow:

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_dup 0)
                      (match_operand:SI 1 "general_operand" "r")))]
       ""
       "...")

which has two operands, one of which must appear in two places, and

     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r")
             (plus:SI (match_operand:SI 1 "general_operand" "0")
                      (match_operand:SI 2 "general_operand" "r")))]
       ""
       "...")

which has three operands, two of which are required by a constraint to
be identical.  If we are considering an insn of the form

     (insn N PREV NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 6) (reg:SI 109)))
       ...)

the first pattern would not apply at all, because this insn does not
contain two identical subexpressions in the right place.  The pattern
would say, "That does not look like an add instruction; try other
patterns."  The second pattern would say, "Yes, that's an add
instruction, but there is something wrong with it."  It would direct
the reload pass of the compiler to generate additional insns to make
the constraint true.  The results might look like this:

     (insn N2 PREV N
       (set (reg:SI 3) (reg:SI 6))
       ...)

     (insn N N2 NEXT
       (set (reg:SI 3)
            (plus:SI (reg:SI 3) (reg:SI 109)))
       ...)

   It is up to you to make sure that each operand, in each pattern, has
constraints that can handle any RTL expression that could be present for
that operand.  (When multiple alternatives are in use, each pattern
must, for each possible combination of operand expressions, have at
least one alternative which can handle that combination of operands.)
The constraints don't need to _allow_ any possible operand--when this is
the case, they do not constrain--but they must at least point the way to
reloading any possible operand so that it will fit.

   * If the constraint accepts whatever operands the predicate permits,
     there is no problem: reloading is never necessary for this operand.

     For example, an operand whose constraints permit everything except
     registers is safe provided its predicate rejects registers.

     An operand whose predicate accepts only constant values is safe
     provided its constraints include the letter `i'.  If any possible
     constant value is accepted, then nothing less than `i' will do; if
     the predicate is more selective, then the constraints may also be
     more selective.

   * Any operand expression can be reloaded by copying it into a
     register.  So if an operand's constraints allow some kind of
     register, it is certain to be safe.  It need not permit all
     classes of registers; the compiler knows how to copy a register
     into another register of the proper class in order to make an
     instruction valid.

   * A nonoffsettable memory reference can be reloaded by copying the
     address into a register.  So if the constraint uses the letter
     `o', all memory references are taken care of.

   * A constant operand can be reloaded by allocating space in memory to
     hold it as preinitialized data.  Then the memory reference can be
     used in place of the constant.  So if the constraint uses the
     letters `o' or `m', constant operands are not a problem.

   * If the constraint permits a constant and a pseudo register used in
     an insn was not allocated to a hard register and is equivalent to
     a constant, the register will be replaced with the constant.  If
     the predicate does not permit a constant and the insn is
     re-recognized for some reason, the compiler will crash.  Thus the
     predicate must always recognize any objects allowed by the
     constraint.

   If the operand's predicate can recognize registers, but the
constraint does not permit them, it can make the compiler crash.  When
this operand happens to be a register, the reload pass will be stymied,
because it does not know how to copy a register temporarily into memory.

   If the predicate accepts a unary operator, the constraint applies to
the operand.  For example, the MIPS processor at ISA level 3 supports an
instruction which adds two registers in `SImode' to produce a `DImode'
result, but only if the registers are correctly sign extended.  This
predicate for the input operands accepts a `sign_extend' of an `SImode'
register.  Write the constraint to indicate the type of register that
is required for the operand of the `sign_extend'.


File: gcc.info,  Node: Multi-Alternative,  Next: Class Preferences,  Prev: Simple Constraints,  Up: Constraints

16.6.2 Multiple Alternative Constraints
---------------------------------------

Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can
combine register or an immediate value into memory, or it can combine
any kind of operand into a register; but it cannot combine one memory
location into another.

   These constraints are represented as multiple alternatives.  An
alternative can be described by a series of letters for each operand.
The overall constraint for an operand is made from the letters for this
operand from the first alternative, a comma, the letters for this
operand from the second alternative, a comma, and so on until the last
alternative.  Here is how it is done for fullword logical-or on the
68000:

     (define_insn "iorsi3"
       [(set (match_operand:SI 0 "general_operand" "=m,d")
             (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                     (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
       ...)

   The first alternative has `m' (memory) for operand 0, `0' for
operand 1 (meaning it must match operand 0), and `dKs' for operand 2.
The second alternative has `d' (data register) for operand 0, `0' for
operand 1, and `dmKs' for operand 2.  The `=' and `%' in the
constraints apply to all the alternatives; their meaning is explained
in the next section (*note Class Preferences::).

   If all the operands fit any one alternative, the instruction is
valid.  Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that
alternative applies.  The alternative requiring the least copying is
chosen.  If two alternatives need the same amount of copying, the one
that comes first is chosen.  These choices can be altered with the `?'
and `!' characters:

`?'
     Disparage slightly the alternative that the `?' appears in, as a
     choice when no alternative applies exactly.  The compiler regards
     this alternative as one unit more costly for each `?' that appears
     in it.

`!'
     Disparage severely the alternative that the `!' appears in.  This
     alternative can still be used if it fits without reloading, but if
     reloading is needed, some other alternative will be used.

   When an insn pattern has multiple alternatives in its constraints,
often the appearance of the assembler code is determined mostly by which
alternative was matched.  When this is so, the C code for writing the
assembler code can use the variable `which_alternative', which is the
ordinal number of the alternative that was actually satisfied (0 for
the first, 1 for the second alternative, etc.).  *Note Output
Statement::.


File: gcc.info,  Node: Class Preferences,  Next: Modifiers,  Prev: Multi-Alternative,  Up: Constraints

16.6.3 Register Class Preferences
---------------------------------

The operand constraints have another function: they enable the compiler
to decide which kind of hardware register a pseudo register is best
allocated to.  The compiler examines the constraints that apply to the
insns that use the pseudo register, looking for the machine-dependent
letters such as `d' and `a' that specify classes of registers.  The
pseudo register is put in whichever class gets the most "votes".  The
constraint letters `g' and `r' also vote: they vote in favor of a
general register.  The machine description says which registers are
considered general.

   Of course, on some machines all registers are equivalent, and no
register classes are defined.  Then none of this complexity is relevant.


File: gcc.info,  Node: Modifiers,  Next: Machine Constraints,  Prev: Class Preferences,  Up: Constraints

16.6.4 Constraint Modifier Characters
-------------------------------------

Here are constraint modifier characters.

`='
     Means that this operand is write-only for this instruction: the
     previous value is discarded and replaced by output data.

`+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the constraints,
     it needs to know which operands are inputs to the instruction and
     which are outputs from it.  `=' identifies an output; `+'
     identifies an operand that is both input and output; all other
     operands are assumed to be input only.

`&'
     Means (in a particular alternative) that this operand is an
     "earlyclobber" operand, which is modified before the instruction is
     finished using the input operands.  Therefore, this operand may
     not lie in a register that is used as an input operand or as part
     of any memory address.

     `&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one alternative
     requires `&' while others do not.  See, for example, the `movdf'
     insn of the 68000.

     An input operand can be tied to an earlyclobber operand if its only
     use as an input occurs before the early result is written.  Adding
     alternatives of this form often allows GCC to produce better code
     when only some of the inputs can be affected by the earlyclobber.
     See, for example, the `mulsi3' insn of the ARM.

     `&' does not obviate the need to write `='.

`%'
     Declares the instruction to be commutative for this operand and the
     following operand.  This means that the compiler may interchange
     the two operands if that is the cheapest way to make all operands
     fit the constraints.  This is often used in patterns for addition
     instructions that really have only two operands: the result must
     go in one of the arguments.  Here for example, is how the 68000
     halfword-add instruction is defined:

          (define_insn "addhi3"
            [(set (match_operand:HI 0 "general_operand" "=m,r")
               (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
                        (match_operand:HI 2 "general_operand" "di,g")))]
            ...)

`#'
     Says that all following characters, up to the next comma, are to be
     ignored as a constraint.  They are significant only for choosing
     register preferences.

`*'
     Says that the following character should be ignored when choosing
     register preferences.  `*' has no effect on the meaning of the
     constraint as a constraint, and no effect on reloading.

     Here is an example: the 68000 has an instruction to sign-extend a
     halfword in a data register, and can also sign-extend a value by
     copying it into an address register.  While either kind of
     register is acceptable, the constraints on an address-register
     destination are less strict, so it is best if register allocation
     makes an address register its goal.  Therefore, `*' is used so
     that the `d' constraint letter (for data register) is ignored when
     computing register preferences.

          (define_insn "extendhisi2"
            [(set (match_operand:SI 0 "general_operand" "=*d,a")
                  (sign_extend:SI
                   (match_operand:HI 1 "general_operand" "0,g")))]
            ...)


File: gcc.info,  Node: Machine Constraints,  Next: No Constraints,  Prev: Modifiers,  Up: Constraints

16.6.5 Constraints for Particular Machines
------------------------------------------

Whenever possible, you should use the general-purpose constraint letters
in `asm' arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters
that usually have very similar meanings across architectures.  The most
commonly used constraints are `m' and `r' (for memory and
general-purpose registers respectively; *note Simple Constraints::), and
`I', usually the letter indicating the most common immediate-constant
format.

   For each machine architecture, the `config/MACHINE.h' file defines
additional constraints.  These constraints are used by the compiler
itself for instruction generation, as well as for `asm' statements;
therefore, some of the constraints are not particularly interesting for
`asm'.  The constraints are defined through these macros:

`REG_CLASS_FROM_LETTER'
     Register class constraints (usually lower case).

`CONST_OK_FOR_LETTER_P'
     Immediate constant constraints, for non-floating point constants of
     word size or smaller precision (usually upper case).

`CONST_DOUBLE_OK_FOR_LETTER_P'
     Immediate constant constraints, for all floating point constants
     and for constants of greater than word size precision (usually
     upper case).

`EXTRA_CONSTRAINT'
     Special cases of registers or memory.  This macro is not required,
     and is only defined for some machines.

   Inspecting these macro definitions in the compiler source for your
machine is the best way to be certain you have the right constraints.
However, here is a summary of the machine-dependent constraints
available on some particular machines.

_ARM family--`arm.h'_

    `f'
          Floating-point register

    `F'
          One of the floating-point constants 0.0, 0.5, 1.0, 2.0, 3.0,
          4.0, 5.0 or 10.0

    `G'
          Floating-point constant that would satisfy the constraint `F'
          if it were negated

    `I'
          Integer that is valid as an immediate operand in a data
          processing instruction.  That is, an integer in the range 0
          to 255 rotated by a multiple of 2

    `J'
          Integer in the range -4095 to 4095

    `K'
          Integer that satisfies constraint `I' when inverted (ones
          complement)

    `L'
          Integer that satisfies constraint `I' when negated (twos
          complement)

    `M'
          Integer in the range 0 to 32

    `Q'
          A memory reference where the exact address is in a single
          register (``m'' is preferable for `asm' statements)

    `R'
          An item in the constant pool

    `S'
          A symbol in the text segment of the current file

_AMD 29000 family--`a29k.h'_

    `l'
          Local register 0

    `b'
          Byte Pointer (`BP') register

    `q'
          `Q' register

    `h'
          Special purpose register

    `A'
          First accumulator register

    `a'
          Other accumulator register

    `f'
          Floating point register

    `I'
          Constant greater than 0, less than 0x100

    `J'
          Constant greater than 0, less than 0x10000

    `K'
          Constant whose high 24 bits are on (1)

    `L'
          16 bit constant whose high 8 bits are on (1)

    `M'
          32 bit constant whose high 16 bits are on (1)

    `N'
          32 bit negative constant that fits in 8 bits

    `O'
          The constant 0x80000000 or, on the 29050, any 32 bit constant
          whose low 16 bits are 0.

    `P'
          16 bit negative constant that fits in 8 bits

    `G'
    `H'
          A floating point constant (in `asm' statements, use the
          machine independent `E' or `F' instead)

_IBM RS6000--`rs6000.h'_

    `b'
          Address base register

    `f'
          Floating point register

    `h'
          `MQ', `CTR', or `LINK' register

    `q'
          `MQ' register

    `c'
          `CTR' register

    `l'
          `LINK' register

    `x'
          `CR' register (condition register) number 0

    `y'
          `CR' register (condition register)

    `z'
          `FPMEM' stack memory for FPR-GPR transfers

    `I'
          Signed 16 bit constant

    `J'
          Constant whose low 16 bits are 0

    `K'
          Constant whose high 16 bits are 0

    `L'
          Constant suitable as a mask operand

    `M'
          Constant larger than 31

    `N'
          Exact power of 2

    `O'
          Zero

    `P'
          Constant whose negation is a signed 16 bit constant

    `G'
          Floating point constant that can be loaded into a register
          with one instruction per word

    `Q'
          Memory operand that is an offset from a register (`m' is
          preferable for `asm' statements)

    `R'
          AIX TOC entry

    `S'
          Constant suitable as a 64-bit mask operand

    `U'
          System V Release 4 small data area reference

_Intel 386--`i386.h'_

    `q'
          `a', `b', `c', or `d' register

    `A'
          `a', or `d' register (for 64-bit ints)

    `f'
          Floating point register

    `t'
          First (top of stack) floating point register

    `u'
          Second floating point register

    `a'
          `a' register

    `b'
          `b' register

    `c'
          `c' register

    `d'
          `d' register

    `D'
          `di' register

    `S'
          `si' register

    `I'
          Constant in range 0 to 31 (for 32 bit shifts)

    `J'
          Constant in range 0 to 63 (for 64 bit shifts)

    `K'
          `0xff'

    `L'
          `0xffff'

    `M'
          0, 1, 2, or 3 (shifts for `lea' instruction)

    `N'
          Constant in range 0 to 255 (for `out' instruction)

    `G'
          Standard 80387 floating point constant

_Intel 960--`i960.h'_

    `f'
          Floating point register (`fp0' to `fp3')

    `l'
          Local register (`r0' to `r15')

    `b'
          Global register (`g0' to `g15')

    `d'
          Any local or global register

    `I'
          Integers from 0 to 31

    `J'
          0

    `K'
          Integers from -31 to 0

    `G'
          Floating point 0

    `H'
          Floating point 1

_MIPS--`mips.h'_

    `d'
          General-purpose integer register

    `f'
          Floating-point register (if available)

    `h'
          `Hi' register

    `l'
          `Lo' register

    `x'
          `Hi' or `Lo' register

    `y'
          General-purpose integer register

    `z'
          Floating-point status register

    `I'
          Signed 16 bit constant (for arithmetic instructions)

    `J'
          Zero

    `K'
          Zero-extended 16-bit constant (for logic instructions)

    `L'
          Constant with low 16 bits zero (can be loaded with `lui')

    `M'
          32 bit constant which requires two instructions to load (a
          constant which is not `I', `K', or `L')

    `N'
          Negative 16 bit constant

    `O'
          Exact power of two

    `P'
          Positive 16 bit constant

    `G'
          Floating point zero

    `Q'
          Memory reference that can be loaded with more than one
          instruction (`m' is preferable for `asm' statements)

    `R'
          Memory reference that can be loaded with one instruction (`m'
          is preferable for `asm' statements)

    `S'
          Memory reference in external OSF/rose PIC format (`m' is
          preferable for `asm' statements)

_Motorola 680x0--`m68k.h'_

    `a'
          Address register

    `d'
          Data register

    `f'
          68881 floating-point register, if available

    `x'
          Sun FPA (floating-point) register, if available

    `y'
          First 16 Sun FPA registers, if available

    `I'
          Integer in the range 1 to 8

    `J'
          16 bit signed number

    `K'
          Signed number whose magnitude is greater than 0x80

    `L'
          Integer in the range -8 to -1

    `M'
          Signed number whose magnitude is greater than 0x100

    `G'
          Floating point constant that is not a 68881 constant

    `H'
          Floating point constant that can be used by Sun FPA

_SPARC--`sparc.h'_

    `f'
          Floating-point register that can hold 32 or 64 bit values.

    `e'
          Floating-point register that can hold 64 or 128 bit values.

    `I'
          Signed 13 bit constant

    `J'
          Zero

    `K'
          32 bit constant with the low 12 bits clear (a constant that
          can be loaded with the `sethi' instruction)

    `G'
          Floating-point zero

    `H'
          Signed 13 bit constant, sign-extended to 32 or 64 bits

    `Q'
          Memory reference that can be loaded with one instruction
          (`m' is more appropriate for `asm' statements)

    `S'
          Constant, or memory address

    `T'
          Memory address aligned to an 8-byte boundary

    `U'
          Even register


File: gcc.info,  Node: No Constraints,  Prev: Machine Constraints,  Up: Constraints

16.6.6 Not Using Constraints
----------------------------

Some machines are so clean that operand constraints are not required.
For example, on the Vax, an operand valid in one context is valid in
any other context.  On such a machine, every operand constraint would
be `g', excepting only operands of "load address" instructions which are
written as if they referred to a memory location's contents but actual
refer to its address.  They would have constraint `p'.

   For such machines, instead of writing `g' and `p' for all the
constraints, you can choose to write a description with empty
constraints.  Then you write `""' for the constraint in every
`match_operand'.  Address operands are identified by writing an
`address' expression around the `match_operand', not by their
constraints.

   When the machine description has just empty constraints, certain
parts of compilation are skipped, making the compiler faster.  However,
few machines actually do not need constraints; all machine descriptions
now in existence use constraints.


File: gcc.info,  Node: Standard Names,  Next: Pattern Ordering,  Prev: Constraints,  Up: Machine Desc

16.7 Standard Pattern Names For Generation
==========================================

Here is a table of the instruction names that are meaningful in the RTL
generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern to accomplish a certain task.

`movM'
     Here M stands for a two-letter machine mode name, in lower case.
     This instruction pattern moves data with that machine mode from
     operand 1 to operand 0.  For example, `movsi' moves full-word data.

     If operand 0 is a `subreg' with mode M of a register whose own
     mode is wider than M, the effect of this instruction is to store
     the specified value in the part of the register that corresponds
     to mode M.  The effect on the rest of the register is undefined.

     This class of patterns is special in several ways.  First of all,
     each of these names _must_ be defined, because there is no other
     way to copy a datum from one place to another.

     Second, these patterns are not used solely in the RTL generation
     pass.  Even the reload pass can generate move insns to copy values
     from stack slots into temporary registers.  When it does so, one
     of the operands is a hard register and the other is an operand
     that can need to be reloaded into a register.

     Therefore, when given such a pair of operands, the pattern must
     generate RTL which needs no reloading and needs no temporary
     registers--no registers other than the operands.  For example, if
     you support the pattern with a `define_expand', then in such a
     case the `define_expand' mustn't call `force_reg' or any other such
     function which might generate new pseudo registers.

     This requirement exists even for subword modes on a RISC machine
     where fetching those modes from memory normally requires several
     insns and some temporary registers.  Look in `spur.md' to see how
     the requirement can be satisfied.

     During reload a memory reference with an invalid address may be
     passed as an operand.  Such an address will be replaced with a
     valid address later in the reload pass.  In this case, nothing may
     be done with the address except to use it as it stands.  If it is
     copied, it will not be replaced with a valid address.  No attempt
     should be made to make such an address into a valid address and no
     routine (such as `change_address') that will do so may be called.
     Note that `general_operand' will fail when applied to such an
     address.

     The global variable `reload_in_progress' (which must be explicitly
     declared if required) can be used to determine whether such special
     handling is required.

     The variety of operands that have reloads depends on the rest of
     the machine description, but typically on a RISC machine these can
     only be pseudo registers that did not get hard registers, while on
     other machines explicit memory references will get optional
     reloads.

     If a scratch register is required to move an object to or from
     memory, it can be allocated using `gen_reg_rtx' prior to life
     analysis.

     If there are cases needing scratch registers after reload, you
     must define `SECONDARY_INPUT_RELOAD_CLASS' and perhaps also
     `SECONDARY_OUTPUT_RELOAD_CLASS' to detect them, and provide
     patterns `reload_inM' or `reload_outM' to handle them.  *Note
     Register Classes::.

     The global variable `no_new_pseudos' can be used to determine if it
     is unsafe to create new pseudo registers.  If this variable is
     nonzero, then it is unsafe to call `gen_reg_rtx' to allocate a new
     pseudo.

     The constraints on a `movM' must permit moving any hard register
     to any other hard register provided that `HARD_REGNO_MODE_OK'
     permits mode M in both registers and `REGISTER_MOVE_COST' applied
     to their classes returns a value of 2.

     It is obligatory to support floating point `movM' instructions
     into and out of any registers that can hold fixed point values,
     because unions and structures (which have modes `SImode' or
     `DImode') can be in those registers and they may have floating
     point members.

     There may also be a need to support fixed point `movM'
     instructions in and out of floating point registers.
     Unfortunately, I have forgotten why this was so, and I don't know
     whether it is still true.  If `HARD_REGNO_MODE_OK' rejects fixed
     point values in floating point registers, then the constraints of
     the fixed point `movM' instructions must be designed to avoid ever
     trying to reload into a floating point register.

`reload_inM'
`reload_outM'
     Like `movM', but used when a scratch register is required to move
     between operand 0 and operand 1.  Operand 2 describes the scratch
     register.  See the discussion of the `SECONDARY_RELOAD_CLASS'
     macro in *note Register Classes::.

`movstrictM'
     Like `movM' except that if operand 0 is a `subreg' with mode M of
     a register whose natural mode is wider, the `movstrictM'
     instruction is guaranteed not to alter any of the register except
     the part which belongs to mode M.

`load_multiple'
     Load several consecutive memory locations into consecutive
     registers.  Operand 0 is the first of the consecutive registers,
     operand 1 is the first memory location, and operand 2 is a
     constant: the number of consecutive registers.

     Define this only if the target machine really has such an
     instruction; do not define this if the most efficient way of
     loading consecutive registers from memory is to do them one at a
     time.

     On some machines, there are restrictions as to which consecutive
     registers can be stored into memory, such as particular starting or
     ending register numbers or only a range of valid counts.  For those
     machines, use a `define_expand' (*note Expander Definitions::) and
     make the pattern fail if the restrictions are not met.

     Write the generated insn as a `parallel' with elements being a
     `set' of one register from the appropriate memory location (you may
     also need `use' or `clobber' elements).  Use a `match_parallel'
     (*note RTL Template::) to recognize the insn.  See `a29k.md' and
     `rs6000.md' for examples of the use of this insn pattern.

`store_multiple'
     Similar to `load_multiple', but store several consecutive registers
     into consecutive memory locations.  Operand 0 is the first of the
     consecutive memory locations, operand 1 is the first register, and
     operand 2 is a constant: the number of consecutive registers.

`addM3'
     Add operand 2 and operand 1, storing the result in operand 0.  All
     operands must have mode M.  This can be used even on two-address
     machines, by means of constraints requiring operands 1 and 0 to be
     the same location.

`subM3', `mulM3'
`divM3', `udivM3', `modM3', `umodM3'
`sminM3', `smaxM3', `uminM3', `umaxM3'
`andM3', `iorM3', `xorM3'
     Similar, for other arithmetic operations.

`mulhisi3'
     Multiply operands 1 and 2, which have mode `HImode', and store a
     `SImode' product in operand 0.

`mulqihi3', `mulsidi3'
     Similar widening-multiplication instructions of other widths.

`umulqihi3', `umulhisi3', `umulsidi3'
     Similar widening-multiplication instructions that do unsigned
     multiplication.

`mulM3_highpart'
     Perform a signed multiplication of operands 1 and 2, which have
     mode M, and store the most significant half of the product in
     operand 0.  The least significant half of the product is discarded.

`umulM3_highpart'
     Similar, but the multiplication is unsigned.

`divmodM4'
     Signed division that produces both a quotient and a remainder.
     Operand 1 is divided by operand 2 to produce a quotient stored in
     operand 0 and a remainder stored in operand 3.

     For machines with an instruction that produces both a quotient and
     a remainder, provide a pattern for `divmodM4' but do not provide
     patterns for `divM3' and `modM3'.  This allows optimization in the
     relatively common case when both the quotient and remainder are
     computed.

     If an instruction that just produces a quotient or just a remainder
     exists and is more efficient than the instruction that produces
     both, write the output routine of `divmodM4' to call
     `find_reg_note' and look for a `REG_UNUSED' note on the quotient
     or remainder and generate the appropriate instruction.

`udivmodM4'
     Similar, but does unsigned division.

`ashlM3'
     Arithmetic-shift operand 1 left by a number of bits specified by
     operand 2, and store the result in operand 0.  Here M is the mode
     of operand 0 and operand 1; operand 2's mode is specified by the
     instruction pattern, and the compiler will convert the operand to
     that mode before generating the instruction.

`ashrM3', `lshrM3', `rotlM3', `rotrM3'
     Other shift and rotate instructions, analogous to the `ashlM3'
     instructions.

`negM2'
     Negate operand 1 and store the result in operand 0.

`absM2'
     Store the absolute value of operand 1 into operand 0.

`sqrtM2'
     Store the square root of operand 1 into operand 0.

     The `sqrt' built-in function of C always uses the mode which
     corresponds to the C data type `double'.

`ffsM2'
     Store into operand 0 one plus the index of the least significant
     1-bit of operand 1.  If operand 1 is zero, store zero.  M is the
     mode of operand 0; operand 1's mode is specified by the instruction
     pattern, and the compiler will convert the operand to that mode
     before generating the instruction.

     The `ffs' built-in function of C always uses the mode which
     corresponds to the C data type `int'.

`one_cmplM2'
     Store the bitwise-complement of operand 1 into operand 0.

`cmpM'
     Compare operand 0 and operand 1, and set the condition codes.  The
     RTL pattern should look like this:

          (set (cc0) (compare (match_operand:M 0 ...)
                              (match_operand:M 1 ...)))

`tstM'
     Compare operand 0 against zero, and set the condition codes.  The
     RTL pattern should look like this:

          (set (cc0) (match_operand:M 0 ...))

     `tstM' patterns should not be defined for machines that do not use
     `(cc0)'.  Doing so would confuse the optimizer since it would no
     longer be clear which `set' operations were comparisons.  The
     `cmpM' patterns should be used instead.

`movstrM'
     Block move instruction.  The addresses of the destination and
     source strings are the first two operands, and both are in mode
     `Pmode'.

     The number of bytes to move is the third operand, in mode M.
     Usually, you specify `word_mode' for M.  However, if you can
     generate better code knowing the range of valid lengths is smaller
     than those representable in a full word, you should provide a
     pattern with a mode corresponding to the range of values you can
     handle efficiently (e.g., `QImode' for values in the range 0-127;
     note we avoid numbers that appear negative) and also a pattern
     with `word_mode'.

     The fourth operand is the known shared alignment of the source and
     destination, in the form of a `const_int' rtx.  Thus, if the
     compiler knows that both source and destination are word-aligned,
     it may provide the value 4 for this operand.

     Descriptions of multiple `movstrM' patterns can only be beneficial
     if the patterns for smaller modes have fewer restrictions on their
     first, second and fourth operands.  Note that the mode M in
     `movstrM' does not impose any restriction on the mode of
     individually moved data units in the block.

     These patterns need not give special consideration to the
     possibility that the source and destination strings might overlap.

`clrstrM'
     Block clear instruction.  The addresses of the destination string
     is the first operand, in mode `Pmode'.  The number of bytes to
     clear is the second operand, in mode M.  See `movstrM' for a
     discussion of the choice of mode.

     The third operand is the known alignment of the destination, in
     the form of a `const_int' rtx.  Thus, if the compiler knows that
     the destination is word-aligned, it may provide the value 4 for
     this operand.

     The use for multiple `clrstrM' is as for `movstrM'.

`cmpstrM'
     Block compare instruction, with five operands.  Operand 0 is the
     output; it has mode M.  The remaining four operands are like the
     operands of `movstrM'.  The two memory blocks specified are
     compared byte by byte in lexicographic order.  The effect of the
     instruction is to store a value in operand 0 whose sign indicates
     the result of the comparison.

`strlenM'
     Compute the length of a string, with three operands.  Operand 0 is
     the result (of mode M), operand 1 is a `mem' referring to the
     first character of the string, operand 2 is the character to
     search for (normally zero), and operand 3 is a constant describing
     the known alignment of the beginning of the string.

`floatMN2'
     Convert signed integer operand 1 (valid for fixed point mode M) to
     floating point mode N and store in operand 0 (which has mode N).

`floatunsMN2'
     Convert unsigned integer operand 1 (valid for fixed point mode M)
     to floating point mode N and store in operand 0 (which has mode N).

`fixMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as a signed number and store in operand 0 (which has mode
     N).  This instruction's result is defined only when the value of
     operand 1 is an integer.

`fixunsMN2'
     Convert operand 1 (valid for floating point mode M) to fixed point
     mode N as an unsigned number and store in operand 0 (which has
     mode N).  This instruction's result is defined only when the value
     of operand 1 is an integer.

`ftruncM2'
     Convert operand 1 (valid for floating point mode M) to an integer
     value, still represented in floating point mode M, and store it in
     operand 0 (valid for floating point mode M).

`fix_truncMN2'
     Like `fixMN2' but works for any floating point value of mode M by
     converting the value to an integer.

`fixuns_truncMN2'
     Like `fixunsMN2' but works for any floating point value of mode M
     by converting the value to an integer.

`truncMN2'
     Truncate operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

`extendMN2'
     Sign-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point or
     both floating point.

`zero_extendMN2'
     Zero-extend operand 1 (valid for mode M) to mode N and store in
     operand 0 (which has mode N).  Both modes must be fixed point.

`extv'
     Extract a bit field from operand 1 (a register or memory operand),
     where operand 2 specifies the width in bits and operand 3 the
     starting bit, and store it in operand 0.  Operand 0 must have mode
     `word_mode'.  Operand 1 may have mode `byte_mode' or `word_mode';
     often `word_mode' is allowed only for registers.  Operands 2 and 3
     must be valid for `word_mode'.

     The RTL generation pass generates this instruction only with
     constants for operands 2 and 3.

     The bit-field value is sign-extended to a full word integer before
     it is stored in operand 0.

`extzv'
     Like `extv' except that the bit-field value is zero-extended.

`insv'
     Store operand 3 (which must be valid for `word_mode') into a bit
     field in operand 0, where operand 1 specifies the width in bits and
     operand 2 the starting bit.  Operand 0 may have mode `byte_mode' or
     `word_mode'; often `word_mode' is allowed only for registers.
     Operands 1 and 2 must be valid for `word_mode'.

     The RTL generation pass generates this instruction only with
     constants for operands 1 and 2.

`movMODEcc'
     Conditionally move operand 2 or operand 3 into operand 0 according
     to the comparison in operand 1.  If the comparison is true,
     operand 2 is moved into operand 0, otherwise operand 3 is moved.

     The mode of the operands being compared need not be the same as
     the operands being moved.  Some machines, sparc64 for example,
     have instructions that conditionally move an integer value based
     on the floating point condition codes and vice versa.

     If the machine does not have conditional move instructions, do not
     define these patterns.

`sCOND'
     Store zero or nonzero in the operand according to the condition
     codes.  Value stored is nonzero iff the condition COND is true.
     COND is the name of a comparison operation expression code, such
     as `eq', `lt' or `leu'.

     You specify the mode that the operand must have when you write the
     `match_operand' expression.  The compiler automatically sees which
     mode you have used and supplies an operand of that mode.

     The value stored for a true condition must have 1 as its low bit,
     or else must be negative.  Otherwise the instruction is not
     suitable and you should omit it from the machine description.  You
     describe to the compiler exactly which value is stored by defining
     the macro `STORE_FLAG_VALUE' (*note Misc::).  If a description
     cannot be found that can be used for all the `sCOND' patterns, you
     should omit those operations from the machine description.

     These operations may fail, but should do so only in relatively
     uncommon cases; if they would fail for common cases involving
     integer comparisons, it is best to omit these patterns.

     If these operations are omitted, the compiler will usually
     generate code that copies the constant one to the target and
     branches around an assignment of zero to the target.  If this code
     is more efficient than the potential instructions used for the
     `sCOND' pattern followed by those required to convert the result
     into a 1 or a zero in `SImode', you should omit the `sCOND'
     operations from the machine description.

`bCOND'
     Conditional branch instruction.  Operand 0 is a `label_ref' that
     refers to the label to jump to.  Jump if the condition codes meet
     condition COND.

     Some machines do not follow the model assumed here where a
     comparison instruction is followed by a conditional branch
     instruction.  In that case, the `cmpM' (and `tstM') patterns should
     simply store the operands away and generate all the required insns
     in a `define_expand' (*note Expander Definitions::) for the
     conditional branch operations.  All calls to expand `bCOND'
     patterns are immediately preceded by calls to expand either a
     `cmpM' pattern or a `tstM' pattern.

     Machines that use a pseudo register for the condition code value,
     or where the mode used for the comparison depends on the condition
     being tested, should also use the above mechanism.  *Note Jump
     Patterns::.

     The above discussion also applies to the `movMODEcc' and `sCOND'
     patterns.

`call'
     Subroutine call instruction returning no value.  Operand 0 is the
     function to call; operand 1 is the number of bytes of arguments
     pushed as a `const_int'; operand 2 is the number of registers used
     as operands.

     On most machines, operand 2 is not actually stored into the RTL
     pattern.  It is supplied for the sake of some RISC machines which
     need to put this information into the assembler code; they can put
     it in the RTL instead of operand 1.

     Operand 0 should be a `mem' RTX whose address is the address of the
     function.  Note, however, that this address can be a `symbol_ref'
     expression even if it would not be a legitimate memory address on
     the target machine.  If it is also not a valid argument for a call
     instruction, the pattern for this operation should be a
     `define_expand' (*note Expander Definitions::) that places the
     address into a register and uses that register in the call
     instruction.

`call_value'
     Subroutine call instruction returning a value.  Operand 0 is the
     hard register in which the value is returned.  There are three more
     operands, the same as the three operands of the `call' instruction
     (but with numbers increased by one).

     Subroutines that return `BLKmode' objects use the `call' insn.

`call_pop', `call_value_pop'
     Similar to `call' and `call_value', except used if defined and if
     `RETURN_POPS_ARGS' is non-zero.  They should emit a `parallel'
     that contains both the function call and a `set' to indicate the
     adjustment made to the frame pointer.

     For machines where `RETURN_POPS_ARGS' can be non-zero, the use of
     these patterns increases the number of functions for which the
     frame pointer can be eliminated, if desired.

`untyped_call'
     Subroutine call instruction returning a value of any type.
     Operand 0 is the function to call; operand 1 is a memory location
     where the result of calling the function is to be stored; operand
     2 is a `parallel' expression where each element is a `set'
     expression that indicates the saving of a function return value
     into the result block.

     This instruction pattern should be defined to support
     `__builtin_apply' on machines where special instructions are needed
     to call a subroutine with arbitrary arguments or to save the value
     returned.  This instruction pattern is required on machines that
     have multiple registers that can hold a return value (i.e.
     `FUNCTION_VALUE_REGNO_P' is true for more than one register).

`return'
     Subroutine return instruction.  This instruction pattern name
     should be defined only if a single instruction can do all the work
     of returning from a function.

     Like the `movM' patterns, this pattern is also used after the RTL
     generation phase.  In this case it is to support machines where
     multiple instructions are usually needed to return from a
     function, but some class of functions only requires one
     instruction to implement a return.  Normally, the applicable
     functions are those which do not need to save any registers or
     allocate stack space.

     For such machines, the condition specified in this pattern should
     only be true when `reload_completed' is non-zero and the function's
     epilogue would only be a single instruction.  For machines with
     register windows, the routine `leaf_function_p' may be used to
     determine if a register window push is required.

     Machines that have conditional return instructions should define
     patterns such as

          (define_insn ""
            [(set (pc)
                  (if_then_else (match_operator
                                   0 "comparison_operator"
                                   [(cc0) (const_int 0)])
                                (return)
                                (pc)))]
            "CONDITION"
            "...")

     where CONDITION would normally be the same condition specified on
     the named `return' pattern.

`untyped_return'
     Untyped subroutine return instruction.  This instruction pattern
     should be defined to support `__builtin_return' on machines where
     special instructions are needed to return a value of any type.

     Operand 0 is a memory location where the result of calling a
     function with `__builtin_apply' is stored; operand 1 is a
     `parallel' expression where each element is a `set' expression
     that indicates the restoring of a function return value from the
     result block.

`nop'
     No-op instruction.  This instruction pattern name should always be
     defined to output a no-op in assembler code.  `(const_int 0)' will
     do as an RTL pattern.

`indirect_jump'
     An instruction to jump to an address which is operand zero.  This
     pattern name is mandatory on all machines.

`casesi'
     Instruction to jump through a dispatch table, including bounds
     checking.  This instruction takes five operands:

       1. The index to dispatch on, which has mode `SImode'.

       2. The lower bound for indices in the table, an integer constant.

       3. The total range of indices in the table--the largest index
          minus the smallest one (both inclusive).

       4. A label that precedes the table itself.

       5. A label to jump to if the index has a value outside the
          bounds.  (If the machine-description macro
          `CASE_DROPS_THROUGH' is defined, then an out-of-bounds index
          drops through to the code following the jump table instead of
          jumping to this label.  In that case, this label is not
          actually used by the `casesi' instruction, but it is always
          provided as an operand.)

     The table is a `addr_vec' or `addr_diff_vec' inside of a
     `jump_insn'.  The number of elements in the table is one plus the
     difference between the upper bound and the lower bound.

`tablejump'
     Instruction to jump to a variable address.  This is a low-level
     capability which can be used to implement a dispatch table when
     there is no `casesi' pattern.

     This pattern requires two operands: the address or offset, and a
     label which should immediately precede the jump table.  If the
     macro `CASE_VECTOR_PC_RELATIVE' evaluates to a nonzero value then
     the first operand is an offset which counts from the address of
     the table; otherwise, it is an absolute address to jump to.  In
     either case, the first operand has mode `Pmode'.

     The `tablejump' insn is always the last insn before the jump table
     it uses.  Its assembler code normally has no need to use the
     second operand, but you should incorporate it in the RTL pattern so
     that the jump optimizer will not delete the table as unreachable
     code.

`canonicalize_funcptr_for_compare'
     Canonicalize the function pointer in operand 1 and store the result
     into operand 0.

     Operand 0 is always a `reg' and has mode `Pmode'; operand 1 may be
     a `reg', `mem', `symbol_ref', `const_int', etc and also has mode
     `Pmode'.

     Canonicalization of a function pointer usually involves computing
     the address of the function which would be called if the function
     pointer were used in an indirect call.

     Only define this pattern if function pointers on the target machine
     can have different values but still call the same function when
     used in an indirect call.

`save_stack_block'
`save_stack_function'
`save_stack_nonlocal'
`restore_stack_block'
`restore_stack_function'
`restore_stack_nonlocal'
     Most machines save and restore the stack pointer by copying it to
     or from an object of mode `Pmode'.  Do not define these patterns on
     such machines.

     Some machines require special handling for stack pointer saves and
     restores.  On those machines, define the patterns corresponding to
     the non-standard cases by using a `define_expand' (*note Expander
     Definitions::) that produces the required insns.  The three types
     of saves and restores are:

       1. `save_stack_block' saves the stack pointer at the start of a
          block that allocates a variable-sized object, and
          `restore_stack_block' restores the stack pointer when the
          block is exited.

       2. `save_stack_function' and `restore_stack_function' do a
          similar job for the outermost block of a function and are
          used when the function allocates variable-sized objects or
          calls `alloca'.  Only the epilogue uses the restored stack
          pointer, allowing a simpler save or restore sequence on some
          machines.

       3. `save_stack_nonlocal' is used in functions that contain labels
          branched to by nested functions.  It saves the stack pointer
          in such a way that the inner function can use
          `restore_stack_nonlocal' to restore the stack pointer.  The
          compiler generates code to restore the frame and argument
          pointer registers, but some machines require saving and
          restoring additional data such as register window information
          or stack backchains.  Place insns in these patterns to save
          and restore any such required data.

     When saving the stack pointer, operand 0 is the save area and
     operand 1 is the stack pointer.  The mode used to allocate the
     save area defaults to `Pmode' but you can override that choice by
     defining the `STACK_SAVEAREA_MODE' macro (*note Storage Layout::).
     You must specify an integral mode, or `VOIDmode' if no save area
     is needed for a particular type of save (either because no save is
     needed or because a machine-specific save area can be used).
     Operand 0 is the stack pointer and operand 1 is the save area for
     restore operations.  If `save_stack_block' is defined, operand 0
     must not be `VOIDmode' since these saves can be arbitrarily nested.

     A save area is a `mem' that is at a constant offset from
     `virtual_stack_vars_rtx' when the stack pointer is saved for use by
     nonlocal gotos and a `reg' in the other two cases.

`allocate_stack'
     Subtract (or add if `STACK_GROWS_DOWNWARD' is undefined) operand 1
     from the stack pointer to create space for dynamically allocated
     data.

     Store the resultant pointer to this space into operand 0.  If you
     are allocating space from the main stack, do this by emitting a
     move insn to copy `virtual_stack_dynamic_rtx' to operand 0.  If
     you are allocating the space elsewhere, generate code to copy the
     location of the space to operand 0.  In the latter case, you must
     ensure this space gets freed when the corresponding space on the
     main stack is free.

     Do not define this pattern if all that must be done is the
     subtraction.  Some machines require other operations such as stack
     probes or maintaining the back chain.  Define this pattern to emit
     those operations in addition to updating the stack pointer.

`probe'
     Some machines require instructions to be executed after space is
     allocated from the stack, for example to generate a reference at
     the bottom of the stack.

     If you need to emit instructions before the stack has been
     adjusted, put them into the `allocate_stack' pattern.  Otherwise,
     define this pattern to emit the required instructions.

     No operands are provided.

`check_stack'
     If stack checking cannot be done on your system by probing the
     stack with a load or store instruction (*note Stack Checking::),
     define this pattern to perform the needed check and signaling an
     error if the stack has overflowed.  The single operand is the
     location in the stack furthest from the current stack pointer that
     you need to validate.  Normally, on machines where this pattern is
     needed, you would obtain the stack limit from a global or
     thread-specific variable or register.

`nonlocal_goto'
     Emit code to generate a non-local goto, e.g., a jump from one
     function to a label in an outer function.  This pattern has four
     arguments, each representing a value to be used in the jump.  The
     first argument is to be loaded into the frame pointer, the second
     is the address to branch to (code to dispatch to the actual label),
     the third is the address of a location where the stack is saved,
     and the last is the address of the label, to be placed in the
     location for the incoming static chain.

     On most machines you need not define this pattern, since GNU CC
     will already generate the correct code, which is to load the frame
     pointer and static chain, restore the stack (using the
     `restore_stack_nonlocal' pattern, if defined), and jump indirectly
     to the dispatcher.  You need only define this pattern if this code
     will not work on your machine.

`nonlocal_goto_receiver'
     This pattern, if defined, contains code needed at the target of a
     nonlocal goto after the code already generated by GNU CC.  You
     will not normally need to define this pattern.  A typical reason
     why you might need this pattern is if some value, such as a
     pointer to a global table, must be restored when the frame pointer
     is restored.  Note that a nonlocal goto only ocurrs within a
     unit-of-translation, so a global table pointer that is shared by
     all functions of a given module need not be restored.  There are
     no arguments.

`exception_receiver'
     This pattern, if defined, contains code needed at the site of an
     exception handler that isn't needed at the site of a nonlocal
     goto.  You will not normally need to define this pattern.  A
     typical reason why you might need this pattern is if some value,
     such as a pointer to a global table, must be restored after
     control flow is branched to the handler of an exception.  There
     are no arguments.

`builtin_setjmp_setup'
     This pattern, if defined, contains additional code needed to
     initialize the `jmp_buf'.  You will not normally need to define
     this pattern.  A typical reason why you might need this pattern is
     if some value, such as a pointer to a global table, must be
     restored.  Though it is preferred that the pointer value be
     recalculated if possible (given the address of a label for
     instance).  The single argument is a pointer to the `jmp_buf'.
     Note that the buffer is five words long and that the first three
     are normally used by the generic mechanism.

`builtin_setjmp_receiver'
     This pattern, if defined, contains code needed at the site of an
     builtin setjmp that isn't needed at the site of a nonlocal goto.
     You will not normally need to define this pattern.  A typical
     reason why you might need this pattern is if some value, such as a
     pointer to a global table, must be restored.  It takes one
     argument, which is the label to which builtin_longjmp transfered
     control; this pattern may be emitted at a small offset from that
     label.

`builtin_longjmp'
     This pattern, if defined, performs the entire action of the
     longjmp.  You will not normally need to define this pattern unless
     you also define `builtin_setjmp_setup'.  The single argument is a
     pointer to the `jmp_buf'.

`eh_epilogue'
     This pattern, if defined, affects the way `__builtin_eh_return',
     and thence `__throw' are built.  It is intended to allow
     communication between the exception handling machinery and the
     normal epilogue code for the target.

     The pattern takes three arguments.  The first is the exception
     context pointer.  This will have already been copied to the
     function return register appropriate for a pointer; normally this
     can be ignored.  The second argument is an offset to be added to
     the stack pointer.  It will have been copied to some arbitrary
     call-clobbered hard reg so that it will survive until after reload
     to when the normal epilogue is generated.  The final argument is
     the address of the exception handler to which the function should
     return.  This will normally need to copied by the pattern to some
     special register.

     This pattern must be defined if `RETURN_ADDR_RTX' does not yield
     something that can be reliably and permanently modified, i.e. a
     fixed hard register or a stack memory reference.

`prologue'
     This pattern, if defined, emits RTL for entry to a function.  The
     function entry is resposible for setting up the stack frame,
     initializing the frame pointer register, saving callee saved
     registers, etc.

     Using a prologue pattern is generally preferred over defining
     `FUNCTION_PROLOGUE' to emit assembly code for the prologue.

     The `prologue' pattern is particularly useful for targets which
     perform instruction scheduling.

`epilogue'
     This pattern, if defined, emits RTL for exit from a function.  The
     function exit is resposible for deallocating the stack frame,
     restoring callee saved registers and emitting the return
     instruction.

     Using an epilogue pattern is generally preferred over defining
     `FUNCTION_EPILOGUE' to emit assembly code for the prologue.

     The `epilogue' pattern is particularly useful for targets which
     perform instruction scheduling or which have delay slots for their
     return instruction.

`sibcall_epilogue'
     This pattern, if defined, emits RTL for exit from a function
     without the final branch back to the calling function.  This
     pattern will be emitted before any sibling call (aka tail call)
     sites.

     The `sibcall_epilogue' pattern must not clobber any arguments used
     for parameter passing or any stack slots for arguments passed to
     the current function.


File: gcc.info,  Node: Pattern Ordering,  Next: Dependent Patterns,  Prev: Standard Names,  Up: Machine Desc

16.8 When the Order of Patterns Matters
=======================================

Sometimes an insn can match more than one instruction pattern.  Then the
pattern that appears first in the machine description is the one used.
Therefore, more specific patterns (patterns that will match fewer
things) and faster instructions (those that will produce better code
when they do match) should usually go first in the description.

   In some cases the effect of ordering the patterns can be used to hide
a pattern when it is not valid.  For example, the 68000 has an
instruction for converting a fullword to floating point and another for
converting a byte to floating point.  An instruction converting an
integer to floating point could match either one.  We put the pattern
to convert the fullword first to make sure that one will be used rather
than the other.  (Otherwise a large integer might be generated as a
single-byte immediate quantity, which would not work.)  Instead of
using this pattern ordering it would be possible to make the pattern
for convert-a-byte smart enough to deal properly with any constant
value.


File: gcc.info,  Node: Dependent Patterns,  Next: Jump Patterns,  Prev: Pattern Ordering,  Up: Machine Desc

16.9 Interdependence of Patterns
================================

Every machine description must have a named pattern for each of the
conditional branch names `bCOND'.  The recognition template must always
have the form

     (set (pc)
          (if_then_else (COND (cc0) (const_int 0))
                        (label_ref (match_operand 0 "" ""))
                        (pc)))

In addition, every machine description must have an anonymous pattern
for each of the possible reverse-conditional branches.  Their templates
look like

     (set (pc)
          (if_then_else (COND (cc0) (const_int 0))
                        (pc)
                        (label_ref (match_operand 0 "" ""))))

They are necessary because jump optimization can turn direct-conditional
branches into reverse-conditional branches.

   It is often convenient to use the `match_operator' construct to
reduce the number of patterns that must be specified for branches.  For
example,

     (define_insn ""
       [(set (pc)
             (if_then_else (match_operator 0 "comparison_operator"
                                           [(cc0) (const_int 0)])
                           (pc)
                           (label_ref (match_operand 1 "" ""))))]
       "CONDITION"
       "...")

   In some cases machines support instructions identical except for the
machine mode of one or more operands.  For example, there may be
"sign-extend halfword" and "sign-extend byte" instructions whose
patterns are

     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:HI 1 ...)))

     (set (match_operand:SI 0 ...)
          (extend:SI (match_operand:QI 1 ...)))

Constant integers do not specify a machine mode, so an instruction to
extend a constant value could match either pattern.  The pattern it
actually will match is the one that appears first in the file.  For
correct results, this must be the one for the widest possible mode
(`HImode', here).  If the pattern matches the `QImode' instruction, the
results will be incorrect if the constant value does not actually fit
that mode.

   Such instructions to extend constants are rarely generated because
they are optimized away, but they do occasionally happen in nonoptimized
compilations.

   If a constraint in a pattern allows a constant, the reload pass may
replace a register with a constant permitted by the constraint in some
cases.  Similarly for memory references.  Because of this substitution,
you should not provide separate patterns for increment and decrement
instructions.  Instead, they should be generated from the same pattern
that supports register-register add insns by examining the operands and
generating the appropriate machine instruction.

